Include Irvine32.inc

.data

; ========== APPLICATION BANNER AND MAIN MENU ==========
banner BYTE "=================================================================================",0Dh,0Ah
       BYTE "__        __   _                            _             _    _____ ____ ",0Dh,0Ah
       BYTE "\ \      / /__| | ___ ___  _ __ ___   ___  | |_ ___      / \  |  ___/ ___|",0Dh,0Ah
       BYTE " \ \ /\ / / _ \ |/ __/ _ \| '_ ` _ \ / _ \ | __/ _ \    / _ \ | |_ | |    ",0Dh,0Ah
       BYTE "  \ V  V /  __/ | (_| (_) | | | | | |  __/ | || (_) |  / ___ \|  _|| |___ ",0Dh,0Ah
       BYTE "  _\_/\_/ \___|_|\___\___/|_| |_| |_|\___|  \__\___/  /_/   \_\_|   \____|",0Dh,0Ah
       BYTE " / ___(_)_ __   ___ _ __ ___   __ _                                       ",0Dh,0Ah
       BYTE "| |   | | '_ \ / _ \ '_ ` _ \ / _` |                                      ",0Dh,0Ah
       BYTE "| |___| | | | |  __/ | | | | | (_| |                                      ",0Dh,0Ah
       BYTE " \____|_|_| |_|\___|_| |_| |_|\__,_|                                      ",0Dh,0Ah
       BYTE "=================================================================================",0Dh,0Ah,0

mainMenuMsg BYTE 0dh, 0ah, "MAIN MENU:", 0dh, 0ah
            BYTE "1. Admin Login", 0dh, 0ah
            BYTE "2. User Login", 0dh, 0ah
            BYTE "3. User Registration", 0dh, 0ah
            BYTE "4. Exit", 0dh, 0ah
            BYTE "Please select an option (1-4): ", 0

; ========== AUTHENTICATION SYSTEM ==========
; Admin default credentials
adminUsername BYTE "admin", 0
adminPassword BYTE "@96iT2", 0

; Login interface messages
adminLoginHeader BYTE 0dh, 0ah, "=== ADMIN LOGIN ===", 0dh, 0ah, 0
userLoginHeader  BYTE 0dh, 0ah, "=== USER LOGIN ===", 0dh, 0ah, 0
usernamePrompt   BYTE "Username: ", 0
passwordPrompt   BYTE "Password (min 8 chars, uppercase, lowercase, number, special): ", 0

; Login attempt tracking
attempts DWORD 0
maxAttempts DWORD 3
maxAttemptsMsg BYTE "Maximum login attempts exceeded. Access denied.", 0dh, 0ah, 0

; Authentication result messages
adminLoginSuccess BYTE 0dh, 0ah, "Admin login successful! Welcome, Administrator.", 0dh, 0ah, 0
userLoginSuccess  BYTE 0dh, 0ah, "User login successful! Welcome, User.", 0dh, 0ah, 0
loginFailed       BYTE 0dh, 0ah, "Login failed! Invalid username or password.", 0dh, 0ah, 0

; Password masking constants
BACKSPACE_KEY EQU 8
ENTER_KEY EQU 13

; ========== USER REGISTRATION SYSTEM ==========
registrationHeader BYTE 0dh, 0ah, "=== USER REGISTRATION ===", 0dh, 0ah, 0
emailPrompt        BYTE "Email (must contain @): ", 0
phonePrompt        BYTE "Phone (Malaysian format 01X-XXXXXXX): ", 0

; Registration validation error messages
passwordError BYTE 0dh, 0ah, "Password must be at least 8 characters with uppercase, lowercase, number, and special character.", 0dh, 0ah, 0
emailError    BYTE 0dh, 0ah, "Email must contain @ symbol.", 0dh, 0ah, 0
phoneError    BYTE 0dh, 0ah, "Phone must be Malaysian format (01X-XXXXXXX or 01XXXXXXXXX, 10-11 digits starting with 01).", 0dh, 0ah, 0

; Registration result messages
registrationSuccess BYTE 0dh, 0ah, "Registration successful! You can now login with your credentials.", 0dh, 0ah, 0
registrationFailed  BYTE 0dh, 0ah, "Registration failed! Username already exists.", 0dh, 0ah, 0
phoneExistsMsg      BYTE 0dh, 0ah, "Registration failed! Phone number already registered.", 0dh, 0ah, 0
maxUsersReached     BYTE 0dh, 0ah, "Registration failed! Maximum number of users reached.", 0dh, 0ah, 0

; ========== USER DATABASE STRUCTURE ==========
; User record constants
MAX_USERS EQU 100
USERNAME_SIZE EQU 20
PASSWORD_SIZE EQU 20
EMAIL_SIZE EQU 30
PHONE_SIZE EQU 15
REWARD_POINTS_SIZE EQU 4
USER_RECORD_SIZE EQU USERNAME_SIZE + PASSWORD_SIZE + EMAIL_SIZE + PHONE_SIZE + REWARD_POINTS_SIZE

; User database storage
userData BYTE MAX_USERS * USER_RECORD_SIZE DUP(0)
userCount DWORD 2

; Current session tracking
currentUser BYTE USERNAME_SIZE DUP(0)
currentUserIndex DWORD -1

; Predefined users for testing
predefUser1 BYTE "user1", 0
predefPass1 BYTE "pass1", 0
predefEmail1 BYTE "user1@gmail.com",0
predefPhone1 BYTE "0123456789",0
predefReward1 WORD 100

predefUser2 BYTE "user2", 0
predefPass2 BYTE "pass2", 0
predefEmail2 BYTE "user2@gmail.com",0
predefPhone2 BYTE "0123456987",0
predefReward2 WORD 150

; ========== USER PROFILE MANAGEMENT ==========
userPortalHeader BYTE 0dh, 0ah, "=== USER PORTAL ===",0dh, 0ah
                 BYTE "1. View Profile", 0dh, 0ah
                 BYTE "2. Booking Movie Tickets", 0dh, 0ah
                 BYTE "3. Logout", 0dh, 0ah
                 BYTE "Please select an option (1-3): ", 0

; Profile display messages
profileHeader    BYTE 0dh, 0ah, "=== USER PROFILE ===", 0dh, 0ah, 0
profileUsername  BYTE "Username: ", 0
profileEmail     BYTE "Email: ", 0
profilePhone     BYTE "Phone: ", 0
profileRewards   BYTE "Reward Points: ", 0
profileNotFound  BYTE "Error: User profile not found!", 0dh, 0ah, 0
editProfilePrompt BYTE "Do you want to edit your profile? (Y/N): ", 0

; Profile editing interface
editProfileHeader BYTE 0dh, 0ah, "=== EDIT PROFILE ===", 0dh, 0ah, 0
editOption1       BYTE "1. Edit Email", 0dh, 0ah, 0
editOption2       BYTE "2. Edit Phone", 0dh, 0ah, 0
editOption3       BYTE "3. Change Password", 0dh, 0ah, 0
editOption4       BYTE "4. Back to User Portal", 0dh, 0ah, 0
editPrompt        BYTE "Select what to edit (1-4): ", 0

; Profile editing prompts
newEmailPrompt    BYTE "Enter new email: ", 0
newPhonePrompt    BYTE "Enter new phone: ", 0
currentPasswordPrompt BYTE "Enter current password: ", 0
newPasswordPrompt BYTE "Enter new password: ", 0
confirmPasswordPrompt BYTE "Confirm new password: ", 0

; Profile update result messages
updateSuccess     BYTE "Profile updated successfully!", 0dh, 0ah, 0
updateFailed      BYTE "Profile update failed!", 0dh, 0ah, 0
passwordMismatch  BYTE "Passwords do not match!", 0dh, 0ah, 0
wrongPassword     BYTE "Current password is incorrect!", 0dh, 0ah, 0
sameAsCurrentMsg  BYTE "New value is same as current value!", 0dh, 0ah, 0

; ========== MOVIE BOOKING SYSTEM ==========
; Main booking portal
bookingHeader BYTE 0dh, 0ah, "======= BOOKING MOVIE =======", 0dh, 0ah
              BYTE "1. 2D", 0dh, 0ah
              BYTE "2. IMAX", 0dh, 0ah
              BYTE "3. Back to User Portal", 0dh, 0ah
              BYTE "Select an option (1-3): ",0

; Movie selection menus
movies2D BYTE "============ 2D MOVIES ============", 0dh, 0ah
         BYTE "1. Avatar: The Way of Fire", 0dh, 0ah
         BYTE "2. Evengers: End Game ", 0dh, 0ah
         BYTE "3. Tatanic", 0dh, 0ah
         BYTE "4. Back to User Portal", 0dh, 0ah
         BYTE "===================================",0dh,0ah
         BYTE "Select a movie (1-4): ",0

moviesIMAX BYTE "=========== IMAX MOVIES ===========", 0dh, 0ah
           BYTE "1. Avatar: The Way of Water", 0dh, 0ah
           BYTE "2. Evengers: End Game", 0dh, 0ah
           BYTE "3. Tatanic", 0dh, 0ah
           BYTE "4. Back to User Portal", 0dh, 0ah
           BYTE "===================================",0dh,0ah
           BYTE "Select a movie (1-4): ",0

; Movie names for display
movie1_2D    BYTE "Avatar: The Way of Fire", 0
movie2_2D    BYTE "Avengers: End Game", 0
movie3_2D    BYTE "Titanic", 0
movie1_IMAX  BYTE "Avatar: The Way of Water", 0
movie2_IMAX  BYTE "Avengers: End Game", 0
movie3_IMAX  BYTE "Titanic", 0
movieType2D  BYTE "2D", 0
movieTypeIMAX BYTE "IMAX", 0

; Showtime selection
showtimesMenu BYTE "=========== SHOWTIMES ===========",0dh,0ah
              BYTE "1. 10:00 AM", 0dh, 0ah
              BYTE "2. 1:00 PM", 0dh, 0ah
              BYTE "3. 4:00 PM", 0dh, 0ah
              BYTE "4. 7:00 PM", 0dh, 0ah
              BYTE "5. Back to Movie Selection", 0dh, 0ah
              BYTE "===================================",0dh,0ah
              BYTE "Select a showtime (1-5): ",0

showtime1Text BYTE "10:00 AM", 0
showtime2Text BYTE "1:00 PM", 0
showtime3Text BYTE "4:00 PM", 0
showtime4Text BYTE "7:00 PM", 0

; ========== SEAT BOOKING SYSTEM ==========
; Seat selection menus
seatMenu2DHeader BYTE "=========== SEAT Selection(2D) ===========",0dh,0ah
                 BYTE "1. Standard (RM12)", 0dh, 0ah
                 BYTE "2. Premium (RM18)", 0dh, 0ah
                 BYTE "3. Couple (RM24)", 0dh, 0ah
                 BYTE "4. Back to Showtime Selection", 0dh, 0ah
                 BYTE "===================================",0dh,0ah,0

seatMenuIMAXHeader BYTE "=========== SEAT Selection(IMAX) ===========",0dh,0ah
                   BYTE "1. Standard (RM20)", 0dh, 0ah
                   BYTE "2. Premium (RM30)", 0dh, 0ah
                   BYTE "3. Couple (RM40)", 0dh, 0ah
                   BYTE "4. Back to Showtime Selection", 0dh, 0ah
                   BYTE "===================================",0dh,0ah,0

seatSelectionPrompt BYTE "Select a seat type (1-4): ",0

; Seat pricing and availability
seatPrices2D DWORD 12, 18, 24
seatPricesIMAX DWORD 20, 30, 40
availableSeats DWORD 50, 20, 30   ; Standard, premium, couple for 10:00 AM
               DWORD 50, 20, 30   ; Standard, premium, couple for 1:00 PM
               DWORD 50, 20, 30   ; Standard, premium, couple for 4:00 PM
               DWORD 50, 20, 30   ; Standard, premium, couple for 7:00 PM

; Seat type names for display
standardText BYTE "Standard", 0
premiumText  BYTE "Premium", 0
coupleText   BYTE "Couple", 0

; Seat quantity management
seatQtyPrompt BYTE "Enter number of seats to book(1-10): ",0
insufficientSeats BYTE "Sorry, not enough seats available. Please choose a smaller quantity.", 0dh, 0ah, 0
invalidQtyMsg BYTE "Invalid seat quantity. Please enter a number between 1 and 10.",0dh,0ah,0
seatsAvailable BYTE "Available seats: ", 0

; ========== COMBO MEAL SYSTEM ==========
comboPrompt BYTE 0dh, 0ah, "Do you want to purchase a combo? (Y/N): ", 0
comboMenuHeader BYTE "============= COMBO MENU =============", 0dh, 0ah
                BYTE "1. Combo A - Popcorn + Soft Drink (RM10.95)", 0dh, 0ah
                BYTE "2. Combo B - Popcorn + Nachos + Soft Drink (RM13.70)", 0dh, 0ah
                BYTE "3. Combo C - Large Popcorn + 2 Soft Drinks + Candy (RM18.88)", 0dh, 0ah
                BYTE "4. No Combo", 0dh, 0ah
                BYTE "======================================", 0dh, 0ah, 0

comboSelectionPrompt BYTE "Select a combo (1-4): ", 0
comboQtyPrompt BYTE "How many combos do you want to purchase? ", 0

; Combo names and pricing
comboAText BYTE "Combo A - Popcorn + Soft Drink", 0
comboBText BYTE "Combo B - Popcorn + Nachos + Soft Drink", 0
comboCText BYTE "Combo C - Large Popcorn + 2 Soft Drinks + Candy", 0
noComboText BYTE "No Combo", 0
comboPrices DWORD 1095, 1370, 1888, 0  ; Prices in cents

invalidComboQtyMsg BYTE "Invalid combo quantity. Please enter a number greater than 0.",0dh,0ah,0

; ========== BOOKING SUMMARY AND PAYMENT ==========
bookingSummary BYTE "============= BOOKING SUMMARY =============", 0dh, 0ah, 0
movieSelected BYTE "Movie: ", 0
showtimeSelected BYTE "Showtime: ", 0
seatTypeSelected BYTE "Seat Type: ", 0
seatsBooked BYTE "Quantity: ", 0
seatsText BYTE " seats", 0
totalPriceText BYTE "Total Price: RM", 0
comboSelectedText BYTE "Combo: ", 0
comboPriceText BYTE "Combo Price: RM", 0
comboQtyText BYTE "Combo Quantity: ", 0
; Add SST-related messages
subtotalText BYTE "Subtotal: RM", 0
sstText BYTE "SST (6%): RM", 0
finalTotalText BYTE "Final Total: RM", 0

confirmBookingPrompt BYTE "Confirm booking? (Y/N): ", 0
paymentPrompt BYTE "Proceed to payment? (Y/N): ", 0
bookingConfirm BYTE 0dh, 0ah, "Booking successful! Enjoy your movie.", 0dh, 0ah, 0
bookingFailed BYTE 0dh, 0ah, "Booking failed! Please try again.", 0dh, 0ah, 0

; ========== CURRENT BOOKING SESSION DATA ==========
currentMovieType DWORD ?  ; 1=2D, 2=IMAX
currentMovie DWORD ?      ; 0=Avatar, 1=Avengers, 2=Titanic
currentShowtime DWORD ?   ; 0=10AM, 1=1PM, 2=4PM, 3=7PM
currentSeatType DWORD ?   ; 0=Standard, 1=Premium, 2=Couple
currentSeatQty DWORD ?    ; Number of seats to book
currentCombo DWORD 0      ; 0=no combo, 1=A, 2=B, 3=C
currentComboQty DWORD 0   ; Quantity of combos selected
; Add SST rate constant
SST_RATE EQU 6            ; 6% SST rate

; ========== INPUT BUFFERS ==========
inputUsername BYTE 20 DUP(0)
inputPassword BYTE 20 DUP(0)
inputEmail BYTE EMAIL_SIZE DUP(0)
inputPhone BYTE PHONE_SIZE DUP(0)
confirmPassword BYTE PASSWORD_SIZE DUP(0)
menuChoice BYTE ?
userChoice DWORD ?

; ========== COMMON SYSTEM MESSAGES ==========
exitMsg BYTE 0dh, 0ah, "Exiting the program. Goodbye!", 0dh, 0ah, 0
InvalidChoice BYTE 0dh, 0ah, "Invalid choice. Please select a valid option.", 0dh, 0ah, 0
continueMsg BYTE 0dh, 0ah, "Press any key to return to main menu...", 0dh, 0ah, 0
returnToPortal BYTE 0dh, 0ah, "Press any key to return to User Portal...", 0dh, 0ah, 0
emptyInputMsg BYTE 0dh, 0ah, "Input cannot be empty. Please try again.", 0dh, 0ah, 0
invalidYNMsg BYTE 0dh, 0ah, "Invalid input! Please enter Y for Yes or N for No.", 0dh, 0ah, 0
decimalPoint BYTE ".", 0

;checkout message
paymentHeader	BYTE 0dh, 0ah, "=========================================================", 0dh, 0ah
				BYTE " ____                                  _   ", 0dh, 0ah
				BYTE "|  _ \ __ _ _   _ _ __ ___   ___ _ __ | |_ ", 0dh, 0ah
				BYTE "| |_) / _` | | | | '_ ` _ \ / _ \ '_ \| __|", 0dh, 0ah
				BYTE "|  __/ (_| | |_| | | | | | |  __/ | | | |_ ", 0dh, 0ah
				BYTE "|_|   \__,_|\__, |_| |_| |_|\___|_| |_|\__|", 0dh, 0ah
				BYTE " __  __     |___/_               _         ", 0dh, 0ah
				BYTE "|  \/  | ___| |_| |__   ___   __| |        ", 0dh, 0ah
				BYTE "| |\/| |/ _ \ __| '_ \ / _ \ / _` |        ", 0dh, 0ah
				BYTE "| |  | |  __/ |_| | | | (_) | (_| |        ", 0dh, 0ah
				BYTE "|_|  |_|\___|\__|_| |_|\___/ \__,_|        ", 0dh, 0ah
				BYTE "=========================================================", 0dh, 0ah
				BYTE "1. Pay with Credit/Debit Card", 0dh, 0ah
				BYTE "2. Pay with E-Wallet", 0dh, 0ah
				BYTE "3. Pay with Online Banking", 0dh, 0ah
				BYTE "4. Pay with Reward Point", 0dh, 0ah
				BYTE "5. Cancel Payment and Return to User Portal", 0dh, 0ah
				BYTE "Please select a payment method (1-4): ", 0

	paymentSuccess BYTE 0dh, 0ah, "Payment successful! Thank you for your purchase.", 0dh, 0ah, 0
	paymentFailed BYTE 0dh, 0ah, "Payment failed! Please try again.", 0dh, 0ah, 0
	paymentChoice BYTE ?

	;E-Wallet payment option
	EwalletPrompt	BYTE "1. GrabPay", 0dh, 0ah
					BYTE "2. Touch 'n Go eWallet", 0dh, 0ah
					BYTE "3. Boost", 0dh, 0ah
					BYTE "Select an E-Wallet (1-3): ", 0

	QRPrompt BYTE "Scan the QR code with your E-Wallet app to complete the payment.", 0dh, 0ah, 0
	QRImage BYTE "+--------------------+", 0dh, 0ah
			BYTE "| ### ## ## # # ## ##|", 0dh, 0ah
			BYTE "| ##   ## ## ## ##  #|", 0dh, 0ah
			BYTE "| ## # ### # ## ## ##|", 0dh, 0ah
			BYTE "| ##  ##   ##  ##  ##|", 0dh, 0ah
			BYTE "| ##   ## ##  # # ## |", 0dh, 0ah
			BYTE "| ## # ##  # ## # ###|", 0dh, 0ah
			BYTE "| ## ## # ## #### ## |", 0dh, 0ah
			BYTE "+--------------------+", 0dh, 0ah, 0
	QRSuccess BYTE "Payment completed via E-Wallet. Thank you!", 0dh, 0ah, 0

	;Credit/Debit Card payment option
	cardNumberPrompt BYTE "Enter your card number (16 digits): ", 0
	cardExpiryPrompt BYTE "Enter card expiry date (MM/YY): ", 0
	cardCVVPrompt BYTE "Enter card CVV (3 digits): ", 0
	cardNumber BYTE 20 DUP(0)
	cardExpiry BYTE 6 DUP(0)
	cardCVV BYTE 4 DUP(0)
	cardError BYTE 0dh, 0ah, "Invalid card details. Please try again.", 0dh, 0ah, 0

	;Online Banking payment option
	bankingPrompt BYTE "Select your bank:", 0dh, 0ah
					BYTE "1. Maybank", 0dh, 0ah
					BYTE "2. CIMB", 0dh, 0ah
					BYTE "3. Public Bank", 0dh, 0ah
					BYTE "Select a bank (1-3): ", 0
	bankingUsernamePrompt BYTE "Enter your online banking username: ", 0
	bankingPasswordPrompt BYTE "Enter your online banking password: ", 0
	bankingUsername BYTE 30 DUP(0)
	bankingPassword BYTE 20 DUP(0)


	processingPayment BYTE 0dh, 0ah, "=== PROCESSING PAYMENT ===", 0dh, 0ah, 0
	cardNumberError BYTE 0dh, 0ah, "Card number must be exactly 16 digits!", 0dh, 0ah, 0
	cardExpiryError BYTE 0dh, 0ah, "Invalid expiry date format! Use MM/YY.", 0dh, 0ah, 0
	cardCVVError BYTE 0dh, 0ah, "CVV must be exactly 3 digits!", 0dh, 0ah, 0
	processingCodeMsg BYTE "Processing your payment code... Please wait.", 0dh, 0ah, 0
	selectedBankMsg BYTE "Selected Bank: ", 0
	maybank BYTE "Maybank", 0
	cimb BYTE "CIMB", 0
	publicbank BYTE "Public Bank", 0
	ewalletOptions BYTE "Selected E-Wallet: ", 0
	grabpay BYTE "GrabPay", 0
	touchngo BYTE "Touch 'n Go eWallet", 0
	boost BYTE "Boost", 0
	cardAttemptsExceeded BYTE 0dh, 0ah, "Maximum card attempts exceeded. Returning to payment method selection.", 0dh, 0ah, 0


	; ========== RECEIPT GENERATION SYSTEM ==========
	receiptHeader BYTE "===============================================", 0dh, 0ah
				  BYTE "           AFC CINEMA RECEIPT", 0dh, 0ah  
				  BYTE "===============================================", 0dh, 0ah, 0

	receiptFooter BYTE "===============================================", 0dh, 0ah
				  BYTE "      Thank you for choosing AFC Cinema!", 0dh, 0ah
				  BYTE "===============================================", 0dh, 0ah, 0

	receiptDateLabel BYTE "Date: ", 0
	receiptTimeLabel BYTE "Time: ", 0
	receiptCustomerLabel BYTE "Customer: ", 0
	slashChar BYTE "/", 0
	colonChar BYTE ":", 0

	; Date and time storage
	currentYear WORD ?
	currentMonth BYTE ?
	currentDay BYTE ?
	currentHour BYTE ?
	currentMinute BYTE ?
	currentSecond BYTE ?
	sysTime SYSTEMTIME <>

	; Add these to your receipt data section
	receiptSeparator BYTE "-----------------------------------------------", 0dh, 0ah, 0
	receiptEquals BYTE "===============================================", 0dh, 0ah, 0
	spacePadding BYTE "                    ", 0

	rewardPointsEarned BYTE 0dh, 0ah, "Congratulations! You earned ", 0
	rewardPointsText BYTE " reward points from this purchase.", 0dh, 0ah, 0
	rewardPointsBalance BYTE "Your new reward points balance: ", 0
	pointsEarnedMsg BYTE 0dh, 0ah, "=== REWARD POINTS EARNED ===", 0dh, 0ah, 0

	availableMsg         BYTE "Your Reward Points: ",0
	requiredMsg          BYTE "Required Points: ",0
	successMsg           BYTE "Payment successful! Points deducted.",0
	notEnoughPointsMsg   BYTE "Not enough reward points for this purchase!",0
	pressAnyKeyMsg       BYTE "Press any key to continue...",0
	finalTotalRM		 DWORD ?
	finalTotalCents		 DWORD ?
	;debugIndexMsg		BYTE "Index: ",0
	;debugCompareMsg		BYTE " Required: ",0
	;debugCompareMsg2	BYTE " Required: ",0
	
.code
main PROC
	; Initialize userData with predefined users
	call InitializeUserData
	call Clrscr
	call MainMenu
	exit
main ENDP

; Calculate and award reward points (RM1 = 1 point)
AwardRewardPoints PROC
	push eax
	push ebx
	push ecx
	push edx
	push esi
	push edi
	
	; Calculate total purchase amount in RM (whole number only)
	call CalculateFinalTotalInRM
	mov ebx, eax  ; Store total RM in EBX (this will be the points to award)
	
	; Get current user's reward points
	mov ebx, currentUserIndex
	cmp ebx, -1
	je AwardPointsEnd  ; Exit if no valid user
	
	mov eax, 4  ; reward points field
	call GetUserField  ; EDI = pointer to reward points
	
	; Load current points and add new points
	movzx ecx, WORD PTR [edi]  ; Load current points
	call CalculateFinalTotalInRM  ; Get total RM again
	add ecx, eax  ; Add earned points to current points
	
	; Store updated points (ensure it doesn't exceed WORD limit)
	cmp ecx, 65535
	jle StorePoints
	mov ecx, 65535  ; Cap at maximum WORD value

StorePoints:
	mov WORD PTR [edi], cx  ; Store updated points
	
	; Display reward points earned message
	call CrLf
	mov edx, OFFSET pointsEarnedMsg
	call WriteString
	
	mov edx, OFFSET rewardPointsEarned
	call WriteString
	call WriteDec  ; Display points earned (still in EAX)
	mov edx, OFFSET rewardPointsText
	call WriteString
	
	; Display new balance
	mov edx, OFFSET rewardPointsBalance
	call WriteString
	mov eax, ecx  ; Move new total to EAX
	call WriteDec
	call CrLf
	call CrLf

AwardPointsEnd:
	pop edi
	pop esi
	pop edx
	pop ecx
	pop ebx
	pop eax
	ret
AwardRewardPoints ENDP

; Calculate final total in whole RM (for reward points calculation)
CalculateFinalTotalInRM PROC
	push ebx
	push ecx
	push edx
	push esi
	
	; Calculate ticket price in cents
	mov eax, currentSeatType
	dec eax  ; Convert to 0-based index
	
	cmp currentMovieType, 0
	je UseRM2DPrices
	
	; Use IMAX prices
	mov ebx, OFFSET seatPricesIMAX
	jmp GetRMPrice

UseRM2DPrices:
	mov ebx, OFFSET seatPrices2D

GetRMPrice:
	mov ecx, [ebx + eax*4]  ; Get price per seat
	mov eax, currentSeatQty
	mul ecx  ; Total ticket price
	
	; Convert to cents
	mov ebx, 100
	mul ebx  ; EAX = ticket price in cents
	mov esi, eax  ; Store ticket price in ESI
	
	; Add combo price if selected
	cmp currentCombo, 0
	je NoRMComboPrice
	
	mov eax, currentCombo
	dec eax  ; Convert to 0-based index
	mov ebx, OFFSET comboPrices
	mov ecx, [ebx + eax*4]  ; Get combo price per unit in cents
	
	; Multiply by combo quantity
	mov eax, currentComboQty
	mul ecx  ; EAX = total combo price in cents
	
	add esi, eax  ; Add combo price to ticket price

NoRMComboPrice:
	; Calculate SST (6% of subtotal) and add to total
	mov eax, esi  ; Get subtotal in cents
	mov ebx, SST_RATE  ; 6%
	mul ebx  ; EAX = subtotal * 6
	mov ebx, 100
	mov edx, 0
	div ebx  ; EAX = SST amount in cents
	
	add esi, eax  ; Add SST to subtotal for final total

	; Convert total from cents to whole RM (divide by 100, ignore remainder)
	mov eax, esi  ; Get total price in cents
	mov ebx, 100
	mov edx, 0
	div ebx  ; EAX = whole RM amount (reward points to award)

	pop esi
	pop edx
	pop ecx
	pop ebx
	ret
CalculateFinalTotalInRM ENDP

; ==========================================================
; Calculate final total in cents (no truncation)
; ==========================================================
CalculateFinalTotalInCents PROC
    push ebx
    push ecx
    push edx
    push esi

    ; ---------- Ticket price ----------
    mov eax, currentSeatType
    dec eax                      ; Convert to 0-based index

    cmp currentMovieType, 0
    je Use2DPrices

    ; IMAX price table
    mov ebx, OFFSET seatPricesIMAX
    jmp GetSeatPrice

Use2DPrices:
    mov ebx, OFFSET seatPrices2D

GetSeatPrice:
    mov ecx, [ebx + eax*4]       ; Seat unit price (RM)
    mov eax, currentSeatQty
    mul ecx                      ; eax = seatQty * unit price (RM)

    ; Convert to cents
    mov ebx, 100
    mul ebx                      ; eax = subtotal in cents
    mov esi, eax                 ; esi = ticket subtotal (cents)

    ; ---------- Combo ----------
    cmp currentCombo, 0
    je SkipCombo

    mov eax, currentCombo
    dec eax
    mov ebx, OFFSET comboPrices
    mov ecx, [ebx + eax*4]       ; Single combo price (cents)

    mov eax, currentComboQty
    mul ecx                      ; eax = combo total (cents)
    add esi, eax

SkipCombo:
    ; ---------- SST (6%) ----------
    mov eax, esi
    mov ebx, SST_RATE            ; 6
    mul ebx                      ; eax = subtotal * 6
    mov ebx, 100
    xor edx, edx
    div ebx                      ; eax = SST (cents)

    add esi, eax                 ; Add SST

    mov eax, esi                 ; return final total in cents

    pop esi
    pop edx
    pop ecx
    pop ebx
    ret
CalculateFinalTotalInCents ENDP

MainMenu PROC
	call Clrscr
	
MainMenuLoop:
	mov edx, OFFSET banner
	call WriteString
	mov edx, OFFSET mainMenuMsg
	call WriteString
	call ReadChar
	call WriteChar
	call CrLf

	cmp al, '1'
	je AdminLoginOption
	cmp al, '2'
	je UserLoginOption
	cmp al, '3'
	je UserRegOption
	cmp al, '4'
	je ExitProgram

	mov edx, OFFSET InvalidChoice
	call WriteString
	jmp MainMenuLoop

AdminLoginOption:
	mov ebx, 0  ; Admin login type
	call PerformLogin
	jmp MainMenuLoop

UserLoginOption:
	mov ebx, 1  ; User login type
	call PerformLogin
	jmp MainMenuLoop

UserRegOption:
	call PerformRegistration
	jmp MainMenuLoop

ExitProgram:
	mov edx, OFFSET exitMsg
	call WriteString
	ret
MainMenu ENDP

UserPortal PROC
	push eax
	push ebx
	push edx
	push ecx
	push esi

	call Clrscr

UserPortalLoop:
	mov edx, OFFSET userPortalHeader
	call WriteString
	mov edx, OFFSET menuChoice
	call WriteString
	call ReadChar
	call WriteChar
	call CrLf
	
	cmp al, '1'
	je ViewProfileOption
	cmp al, '2'
	je BookingOption
	cmp al, '3'
	je LogoutOption

	mov edx, OFFSET InvalidChoice
	call WriteString
	jmp UserPortalLoop

ViewProfileOption:
	call ViewUserProfile
	jmp UserPortalLoop

BookingOption:
	call BookingPortal
	jmp UserPortalLoop

LogoutOption:
	jmp UserPortalEnd

UserPortalEnd:
	pop esi
	pop ecx
	pop edx
	pop ebx
	pop eax
	ret
UserPortal ENDP

; Initialize userData array with predefined users
InitializeUserData PROC
	push eax
	push ecx
	push esi
	push edi

	; Copy user1 data to userData[0]
	mov edi, OFFSET userData                    ; Point to first user record
	
	; Copy username
	mov esi, OFFSET predefUser1
	mov ecx, USERNAME_SIZE
	call CopyStringToBuffer
	
	; Copy password  
	add edi, USERNAME_SIZE                      ; Move to password field
	mov esi, OFFSET predefPass1
	mov ecx, PASSWORD_SIZE
	call CopyStringToBuffer
	
	; Copy email
	add edi, PASSWORD_SIZE                      ; Move to email field
	mov esi, OFFSET predefEmail1
	mov ecx, EMAIL_SIZE
	call CopyStringToBuffer
	
	; Copy phone
	add edi, EMAIL_SIZE                         ; Move to phone field
	mov esi, OFFSET predefPhone1
	mov ecx, PHONE_SIZE
	call CopyStringToBuffer

	; Copy reward points (as WORD, not string)
	add edi, PHONE_SIZE                        ; Move to reward points field
	mov ax, predefReward1                      ; Load reward points value
	mov WORD PTR [edi], ax                     ; Store as WORD

	; Copy user2 data to userData[1]
	mov edi, OFFSET userData
	add edi, USER_RECORD_SIZE                   ; Point to second user record
	
	; Copy username
	mov esi, OFFSET predefUser2
	mov ecx, USERNAME_SIZE
	call CopyStringToBuffer
	
	; Copy password
	add edi, USERNAME_SIZE
	mov esi, OFFSET predefPass2
	mov ecx, PASSWORD_SIZE
	call CopyStringToBuffer
	
	; Copy email
	add edi, PASSWORD_SIZE
	mov esi, OFFSET predefEmail2
	mov ecx, EMAIL_SIZE
	call CopyStringToBuffer
	
	; Copy phone
	add edi, EMAIL_SIZE
	mov esi, OFFSET predefPhone2
	mov ecx, PHONE_SIZE
	call CopyStringToBuffer

	; Copy reward points (as WORD, not string)
	add edi, PHONE_SIZE                        ; Move to reward points field
	mov ax, predefReward2                      ; Load reward points value
	mov WORD PTR [edi], ax                     ; Store as WORD

	pop edi
	pop esi
	pop ecx
	pop eax
	ret
InitializeUserData ENDP

; Helper procedure to copy string to buffer
CopyStringToBuffer PROC
	; ESI = source string, EDI = destination buffer, ECX = buffer size
	push eax
	push ebx
	push ecx
	push esi
	push edi
	
	; Clear the destination buffer first
	mov al, 0
	push edi
	rep stosb
	pop edi
	
	; Copy string until null terminator or buffer limit
	mov ebx, ecx                                ; Save buffer size
	dec ebx                                     ; Leave space for null terminator

CopyLoop:
	cmp ebx, 0
	je CopyDone
	mov al, [esi]
	cmp al, 0
	je CopyDone
	mov [edi], al
	inc esi
	inc edi
	dec ebx
	jmp CopyLoop

CopyDone:
	pop edi
	pop esi
	pop ecx
	pop ebx
	pop eax
	ret
CopyStringToBuffer ENDP

; Get user data by index
GetUserData PROC
	; Input: EBX = user index (0-based)
	; Output: EDI = pointer to user record
	push eax
	
	mov eax, USER_RECORD_SIZE
	mul ebx                                     ; EAX = index * record_size
	mov edi, OFFSET userData
	add edi, eax                                ; EDI points to user[index]
	
	pop eax
	ret
GetUserData ENDP

; Get specific field from user record
GetUserField PROC
	; Input: EBX = user index, EAX = field type (0=username, 1=password, 2=email, 3=phone)
	; Output: EDI = pointer to field
	push ecx
	
	call GetUserData                            ; EDI = pointer to user record
	
	cmp eax, 0
	je GetUsername
	cmp eax, 1
	je GetPassword
	cmp eax, 2
	je GetEmail
	cmp eax, 3
	je GetPhone
	cmp eax, 4
	je GetRewardPoints
	jmp GetFieldEnd

GetUsername:
	; EDI already points to username (offset 0)
	jmp GetFieldEnd

GetPassword:
	add edi, USERNAME_SIZE
	jmp GetFieldEnd

GetEmail:
	add edi, USERNAME_SIZE + PASSWORD_SIZE
	jmp GetFieldEnd

GetPhone:
	add edi, USERNAME_SIZE + PASSWORD_SIZE + EMAIL_SIZE
	jmp GetFieldEnd

GetRewardPoints:
	add edi, USERNAME_SIZE + PASSWORD_SIZE + EMAIL_SIZE + PHONE_SIZE
	jmp GetFieldEnd

GetFieldEnd:
	pop ecx
	ret
GetUserField ENDP

; Store current logged-in user information
StoreCurrentUser PROC
	push eax
	push ebx
	push ecx
	push esi
	push edi
	
	; Clear current user buffer
	mov ecx, USERNAME_SIZE
	mov esi, OFFSET currentUser
	call ClearBuffer
	
	; Copy username to current user buffer
	mov esi, OFFSET inputUsername
	mov edi, OFFSET currentUser
	mov ecx, USERNAME_SIZE
	call CopyStringToBuffer
	
	; Find user index in database
	mov ebx, 0

FindUserIndexLoop:
	cmp ebx, userCount
	jae UserIndexNotFound

	mov eax, 0  ; Username field
	call GetUserField
	
	mov esi, OFFSET currentUser
	call CompareStrings
	cmp eax, 0
	je UserIndexFound
	
	inc ebx
	jmp FindUserIndexLoop

UserIndexFound:
	mov currentUserIndex, ebx
	jmp StoreCurrentUserEnd

UserIndexNotFound:
	mov currentUserIndex, -1

StoreCurrentUserEnd:
	pop edi
	pop esi
	pop ecx
	pop ebx
	pop eax
	ret
StoreCurrentUser ENDP

; User Registration Procedure
PerformRegistration PROC
	push eax
	push ebx
	push edx
	
	; Display registration header
	mov edx, OFFSET registrationHeader
	call WriteString

RegistrationLoop:
	; Check if maximum users reached
	mov eax, userCount
	cmp eax, MAX_USERS
	jae MaxUsersError

	; Get registration input
	call GetRegistrationInput

	; Check for empty inputs
	mov esi, OFFSET inputUsername
	call IsEmptyString
	cmp eax, 1
	je EmptyRegistrationInput

	mov esi, OFFSET inputPassword
	call IsEmptyString
	cmp eax, 1
	je EmptyRegistrationInput

	mov esi, OFFSET inputEmail
	call IsEmptyString
	cmp eax, 1
	je EmptyRegistrationInput

	mov esi, OFFSET inputPhone
	call IsEmptyString
	cmp eax, 1
	je EmptyRegistrationInput

	; Validate password strength
	mov esi, OFFSET inputPassword
	call ValidatePassword
	cmp eax, 0
	je PasswordValidationFailed

	; Validate email format
	mov esi, OFFSET inputEmail
	call ValidateEmail
	cmp eax, 0
	je EmailValidationFailed

	; Validate phone number
	mov esi, OFFSET inputPhone
	call ValidatePhone
	cmp eax, 0
	je PhoneValidationFailed

	; Check if username already exists
	call CheckUsernameExists
	cmp eax, 1
	je UsernameExistsError

	; Check if phone number already exists
	call CheckPhoneExists
	cmp eax, 1
	jne AddUser
	jmp PhoneAlreadyExists

AddUser:
	; Add new user
	call AddNewUser
	cmp eax, 1
	je RegistrationSuccessful

	; Registration failed for unknown reason
	jmp RegistrationEnd

EmptyRegistrationInput:
	mov edx, OFFSET emptyInputMsg
	call WriteString
	jmp RegistrationLoop

PasswordValidationFailed:
	mov edx, OFFSET passwordError
	call WriteString
	jmp RegistrationLoop

EmailValidationFailed:
	mov edx, OFFSET emailError
	call WriteString
	jmp RegistrationLoop

PhoneValidationFailed:
	mov edx, OFFSET phoneError
	call WriteString
	jmp RegistrationLoop

MaxUsersError:
	mov edx, OFFSET maxUsersReached
	call WriteString
	jmp RegistrationEnd

UsernameExistsError:
	mov edx, OFFSET registrationFailed
	call WriteString
	jmp RegistrationLoop

PhoneAlreadyExists:
	mov edx, OFFSET phoneExistsMsg
	call WriteString
	jmp RegistrationLoop

RegistrationSuccessful:
	mov edx, OFFSET registrationSuccess
	call WriteString

RegistrationEnd:
	mov edx, OFFSET continueMsg
	call WriteString
	call ReadChar
	call Clrscr
	
	pop edx
	pop ebx
	pop eax
	ret
PerformRegistration ENDP

; Validate password strength
; Input: ESI = password string
; Output: EAX = 1 if valid, 0 if invalid
ValidatePassword PROC
	push ebx
	push ecx
	push edx
	push esi
	
	mov ecx, 0          ; Length counter
	mov ebx, 0          ; Flags: bit 0=uppercase, bit 1=lowercase, bit 2=digit, bit 3=special
	
ValidatePasswordLoop:
	mov al, [esi]
	cmp al, 0
	je CheckPasswordRequirements
	
	inc ecx             ; Increment length
	
	; Check for uppercase (A-Z)
	cmp al, 'A'
	jl CheckLowercase
	cmp al, 'Z'
	jg CheckLowercase
	or ebx, 1           ; Set uppercase flag
	jmp NextPasswordChar

CheckLowercase:
	; Check for lowercase (a-z)
	cmp al, 'a'
	jl CheckDigit
	cmp al, 'z'
	jg CheckDigit
	or ebx, 2           ; Set lowercase flag
	jmp NextPasswordChar

CheckDigit:
	; Check for digit (0-9)
	cmp al, '0'
	jl CheckSpecial
	cmp al, '9'
	jg CheckSpecial
	or ebx, 4           ; Set digit flag
	jmp NextPasswordChar

CheckSpecial:
	; Check for special characters
	cmp al, '!'
	je SetSpecialFlag
	cmp al, '@'
	je SetSpecialFlag
	cmp al, '#'
	je SetSpecialFlag
	cmp al, '$'
	je SetSpecialFlag
	cmp al, '%'
	je SetSpecialFlag
	cmp al, '^'
	je SetSpecialFlag
	cmp al, '&'
	je SetSpecialFlag
	cmp al, '*'
	je SetSpecialFlag
	cmp al, '('
	je SetSpecialFlag
	cmp al, ')'
	je SetSpecialFlag
	cmp al, '-'
	je SetSpecialFlag
	cmp al, '_'
	je SetSpecialFlag
	cmp al, '+'
	je SetSpecialFlag
	cmp al, '='
	je SetSpecialFlag
	jmp NextPasswordChar

SetSpecialFlag:
	or ebx, 8           ; Set special character flag

NextPasswordChar:
	inc esi
	jmp ValidatePasswordLoop

CheckPasswordRequirements:
	; Check minimum length (8 characters)
	cmp ecx, 8
	jl PasswordInvalid
	
	; Check all requirements are met (all 4 bits should be set)
	cmp ebx, 15         ; 15 = 1111 in binary (all flags set)
	je PasswordValid

PasswordInvalid:
	mov eax, 0
	jmp ValidatePasswordEnd

PasswordValid:
	mov eax, 1

ValidatePasswordEnd:
	pop esi
	pop edx
	pop ecx
	pop ebx
	ret
ValidatePassword ENDP

; Validate email format (must contain @)
; Input: ESI = email string
; Output: EAX = 1 if valid, 0 if invalid
ValidateEmail PROC
	push esi
	
ValidateEmailLoop:
	mov al, [esi]
	cmp al, 0
	je EmailInvalid     ; Reached end without finding @
	
	cmp al, '@'
	je EmailValid
	
	inc esi
	jmp ValidateEmailLoop

EmailValid:
	mov eax, 1
	jmp ValidateEmailEnd

EmailInvalid:
	mov eax, 0

ValidateEmailEnd:
	pop esi
	ret
ValidateEmail ENDP

; Validate Malaysian phone number format
; Input: ESI = phone string
; Output: EAX = 1 if valid, 0 if invalid
ValidatePhone PROC
	push ebx
	push ecx
	push esi
	
	mov ecx, 0          ; Length counter
	
	; Check if string is empty
	mov al, [esi]
	cmp al, 0
	je PhoneInvalid

	; Check if starts with '0'
	cmp al, '0'
	jne PhoneInvalid
	inc esi
	inc ecx

	; Check if second character is '1'
	mov al, [esi]
	cmp al, '1'
	jne PhoneInvalid
	inc esi
	inc ecx

CountDigitsLoop:
	mov al, [esi]
	cmp al, 0
	je CheckPhoneLength
	
	; Skip hyphen if present
	cmp al, '-'
	je SkipHyphen
	
	; Check if character is a digit (0-9)
	cmp al, '0'
	jl PhoneInvalid
	cmp al, '9'
	jg PhoneInvalid
	
	inc ecx
	inc esi
	jmp CountDigitsLoop

SkipHyphen:
	inc esi
	jmp CountDigitsLoop

CheckPhoneLength:
	; Malaysian phone numbers: 10-11 digits total
	cmp ecx, 10
	jl PhoneInvalid
	cmp ecx, 11
	jg PhoneInvalid

PhoneValid:
	mov eax, 1
	jmp ValidatePhoneEnd

PhoneInvalid:
	mov eax, 0

ValidatePhoneEnd:
	pop esi
	pop ecx
	pop ebx
	ret
ValidatePhone ENDP

; Check if phone number already exists (excluding current user)
; Output: EAX = 1 if exists, 0 if not
CheckPhoneExists PROC
	push ebx
	push edi
	
	mov ebx, 0		; Start from first user

CheckPhoneLoop:
	cmp ebx, userCount
	jae PhoneNotExists

	; Skip current user when editing
	cmp ebx, currentUserIndex
	je SkipCurrentUser

	; Get phone field for current user
	mov eax, 3		; 3 = phone field
	call GetUserField	; EDI = pointer to phone
	
	; Compare with input phone
	mov esi, OFFSET inputPhone
	call CompareStrings
	cmp eax, 0
	je PhoneExists

SkipCurrentUser:
	inc ebx
	jmp CheckPhoneLoop

PhoneExists:
	mov eax, 1
	jmp CheckPhoneEnd

PhoneNotExists:
	mov eax, 0

CheckPhoneEnd:
	pop edi
	pop ebx
	ret
CheckPhoneExists ENDP

; Get registration input from user
GetRegistrationInput PROC
	; Clear all input buffers
	mov ecx, USERNAME_SIZE
	mov esi, OFFSET inputUsername
	call ClearBuffer

	mov ecx, PASSWORD_SIZE
	mov esi, OFFSET inputPassword
	call ClearBuffer

	mov ecx, EMAIL_SIZE
	mov esi, OFFSET inputEmail
	call ClearBuffer

	mov ecx, PHONE_SIZE
	mov esi, OFFSET inputPhone
	call ClearBuffer

	; Get username
	call Crlf
	mov edx, OFFSET usernamePrompt
	call WriteString
	mov edx, OFFSET inputUsername
	mov ecx, USERNAME_SIZE
	call ReadString

	; Get password with masking
	mov edx, OFFSET passwordPrompt
	call WriteString
	mov edx, OFFSET inputPassword
	mov ecx, PASSWORD_SIZE
	call ReadPasswordMasked

	; Get email
	mov edx, OFFSET emailPrompt
	call WriteString
	mov edx, OFFSET inputEmail
	mov ecx, EMAIL_SIZE
	call ReadString

	; Get phone
	mov edx, OFFSET phonePrompt
	call WriteString
	mov edx, OFFSET inputPhone
	mov ecx, PHONE_SIZE
	call ReadString

	ret
GetRegistrationInput ENDP

; Check if username already exists
; Output: EAX = 1 if exists, 0 if not
CheckUsernameExists PROC
	push ebx
	push edi
	
	mov ebx, 0		; Start from first user

CheckUsernameLoop:
	cmp ebx, userCount
	jae UsernameNotExists

	; Get username field for current user
	mov eax, 0		; 0 = username field
	call GetUserField	; EDI = pointer to username
	
	; Compare with input username
	mov esi, OFFSET inputUsername
	call CompareStrings
	cmp eax, 0
	je UsernameExists

	inc ebx
	jmp CheckUsernameLoop

UsernameExists:
	mov eax, 1
	jmp CheckUsernameEnd

UsernameNotExists:
	mov eax, 0

CheckUsernameEnd:
	pop edi
	pop ebx
	ret
CheckUsernameExists ENDP

; Add new user to userData array
; Output: EAX = 1 if successful, 0 if failed
AddNewUser PROC
	push ebx
	push ecx
	push esi
	push edi
	
	; Get pointer to new user record
	mov ebx, userCount
	call GetUserData		; EDI = pointer to new user record
	
	; Copy username
	mov esi, OFFSET inputUsername
	mov ecx, USERNAME_SIZE
	call CopyStringToBuffer
	
	; Copy password
	add edi, USERNAME_SIZE
	mov esi, OFFSET inputPassword
	mov ecx, PASSWORD_SIZE
	call CopyStringToBuffer
	
	; Copy email
	add edi, PASSWORD_SIZE
	mov esi, OFFSET inputEmail
	mov ecx, EMAIL_SIZE
	call CopyStringToBuffer
	
	; Copy phone
	add edi, EMAIL_SIZE
	mov esi, OFFSET inputPhone
	mov ecx, PHONE_SIZE
	call CopyStringToBuffer
	
	; Increment user count
	inc userCount
	
	mov eax, 1		; Success
	
	pop edi
	pop esi
	pop ecx
	pop ebx
	ret
AddNewUser ENDP

; Input: EBX = login type (0 = admin, 1 = user)
PerformLogin PROC
	push eax
	push edx
	
	; Display appropriate header
	cmp ebx, 0
	je DisplayAdminHeader
	mov edx, OFFSET userLoginHeader
	jmp DisplayHeader
DisplayAdminHeader:
	mov edx, OFFSET adminLoginHeader
DisplayHeader:
	call WriteString
	mov attempts, 0

LoginLoop:
	mov eax, attempts
	cmp eax, maxAttempts
	jae MaxAttemptsReached		; Check max attempts at the beginning

	call GetCredentials

	; Check for empty inputs
	mov esi, OFFSET inputUsername
	call IsEmptyString
	cmp eax, 1
	je EmptyInput

	mov esi, OFFSET inputPassword
	call IsEmptyString
	cmp eax, 1
	je EmptyInput

	; Validate credentials based on login type
	call ValidateCredentials	; EBX already contains login type
	cmp eax, 1 
	je LoginSuccessful

	; Login failed
	inc attempts
	mov edx, OFFSET loginFailed
	call WriteString
	
	; Jump back to check attempts at the beginning of the loop
	jmp LoginLoop

EmptyInput:
	mov edx, OFFSET emptyInputMsg
	call WriteString
	jmp LoginLoop

LoginSuccessful:
	; Store current user for profile viewing (only for user login)
	cmp ebx, 1
	jne SkipStoreUser
	call StoreCurrentUser

SkipStoreUser:
	; Display appropriate success message
	cmp ebx, 0
	je DisplayAdminSuccess
	mov edx, OFFSET userLoginSuccess
	jmp DisplaySuccess
DisplayAdminSuccess:
	mov edx, OFFSET adminLoginSuccess
DisplaySuccess:
	call WriteString
	
	; Only call UserPortal for user login
	cmp ebx, 1
	jne LoginEnd
	call UserPortal
	jmp LoginEnd

MaxAttemptsReached:
	mov edx, OFFSET maxAttemptsMsg
	call WriteString

LoginEnd:
	mov edx, OFFSET continueMsg
	call WriteString
	call ReadChar
	call Clrscr
	
	pop edx
	pop eax
	ret
PerformLogin ENDP


; View user profile - displays current logged-in user's information
ViewUserProfile PROC
	push eax
	push ebx
	push edx
	push ecx
	push esi
	push edi
	
	call Clrscr
	
ViewProfileLoop:
	; Display profile header
	mov edx, OFFSET profileHeader
	call WriteString
	
	; Use stored user index
	mov ebx, currentUserIndex
	cmp ebx, -1
	je UserNotFound

	; Display username
	mov edx, OFFSET profileUsername
	call WriteString
	mov eax, 0		; username field
	call GetUserField	; EDI = pointer to username
	mov edx, edi
	call WriteString
	call CrLf
	
	; Display email
	mov edx, OFFSET profileEmail
	call WriteString
	mov eax, 2		; email field
	call GetUserField	; EDI = pointer to email
	mov edx, edi
	call WriteString
	call CrLf
	
	; Display phone
	mov edx, OFFSET profilePhone
	call WriteString
	mov eax, 3		; phone field
	call GetUserField	; EDI = pointer to phone
	mov edx, edi
	call WriteString
	call CrLf

	; Display reward points
	mov edx, OFFSET profileRewards
	call WriteString
	mov eax, 4		; reward points field
	call GetUserField	; EDI = pointer to reward points
	movzx eax, WORD PTR [edi] ; Load reward points (WORD)
	call WriteDec
	call CrLf
	
	mov edx, OFFSET editProfilePrompt
	call WriteString
	call ValidateYNInput	; <-- FIX: Use validation for Y/N input
	cmp al, 'Y'
	je CallEditProfile
	cmp al, 'y'
	je CallEditProfile
	; Only need to check for 'N'/'n' now
	jmp ProfileDisplayComplete

CallEditProfile:
	call EditUserProfile
	jmp ProfileDisplayComplete

UserNotFound:
	mov edx, OFFSET profileNotFound
	call WriteString

ProfileDisplayComplete:
	mov edx, OFFSET returnToPortal
	call WriteString
	call ReadChar

	pop edi
	pop esi
	pop ecx
	pop edx
	pop ebx
	pop eax
	ret
ViewUserProfile ENDP

; Edit user profile - allows editing of email, phone, and password
EditUserProfile PROC
	push eax
	push ebx
	push edx
	push ecx
	push esi
	push edi

EditProfileLoop:
	call Clrscr
	
	; Display edit profile header
	mov edx, OFFSET editProfileHeader
	call WriteString
	mov edx, OFFSET editOption1
	call WriteString
	mov edx, OFFSET editOption2
	call WriteString
	mov edx, OFFSET editOption3
	call WriteString
	mov edx, OFFSET editOption4
	call WriteString
	mov edx, OFFSET editPrompt
	call WriteString
	
	call ReadChar
	call WriteChar
	call CrLf
	
	cmp al, '1'
	je EditEmailOption
	cmp al, '2'
	je EditPhoneOption
	cmp al, '3'
	je ChangePasswordOption
	cmp al, '4'
	je EditProfileEnd
	
	; Invalid choice
	mov edx, OFFSET InvalidChoice
	call WriteString
	jmp EditProfileLoop

EditEmailOption:
	call EditEmail
	jmp EditProfileLoop

EditPhoneOption:
	call EditPhone
	jmp EditProfileLoop

ChangePasswordOption:
	call ChangePassword
	jmp EditProfileLoop

EditProfileEnd:
	pop edi
	pop esi
	pop ecx
	pop edx
	pop ebx
	pop eax
	ret
EditUserProfile ENDP

; Edit email procedure
EditEmail PROC
	push eax
	push ebx
	push ecx
	push esi
	push edi
	
	call Clrscr
	
	; Show current email
	mov ebx, currentUserIndex
	mov edx, OFFSET profileEmail
	call WriteString
	mov eax, 2		; email field
	call GetUserField	; EDI = pointer to email
	mov edx, edi
	call WriteString
	call CrLf
	call CrLf
	
	; Get new email
	mov edx, OFFSET newEmailPrompt
	call WriteString
	mov edx, OFFSET inputEmail
	mov ecx, EMAIL_SIZE
	call ReadString
	
	; Validate new email
	mov esi, OFFSET inputEmail
	call IsEmptyString
	cmp eax, 1
	je EditEmailEnd
	
	call ValidateEmail
	cmp eax, 0
	je EmailValidationFailed
	
	; Check if same as current
	mov ebx, currentUserIndex
	mov eax, 2		; email field
	call GetUserField	; EDI = pointer to current email
	mov esi, OFFSET inputEmail
	call CompareStrings
	cmp eax, 0
	je SameEmailValue
	
	; Update email
	mov ebx, currentUserIndex
	mov eax, 2		; email field
	call GetUserField	; EDI = pointer to email
	mov esi, OFFSET inputEmail
	mov ecx, EMAIL_SIZE
	call CopyStringToBuffer
	
	mov edx, OFFSET updateSuccess
	call WriteString
	jmp EditEmailEnd

EmailValidationFailed:
	mov edx, OFFSET emailError
	call WriteString
	jmp EditEmailEnd

SameEmailValue:
	mov edx, OFFSET sameAsCurrentMsg
	call WriteString

EditEmailEnd:
	mov edx, OFFSET returnToPortal
	call WriteString
	call ReadChar
	
	pop edi
	pop esi
	pop ecx
	pop ebx
	pop eax
	ret
EditEmail ENDP

; Edit phone procedure
EditPhone PROC
	push eax
	push ebx
	push ecx
	push esi
	push edi
	
	call Clrscr
	
	; Show current phone
	mov ebx, currentUserIndex
	mov edx, OFFSET profilePhone
	call WriteString
	mov eax, 3		; phone field
	call GetUserField	; EDI = pointer to phone
	mov edx, edi
	call WriteString
	call CrLf
	call CrLf
	
	; Get new phone
	mov edx, OFFSET newPhonePrompt
	call WriteString
	mov edx, OFFSET inputPhone
	mov ecx, PHONE_SIZE
	call ReadString
	
	; Validate new phone
	mov esi, OFFSET inputPhone
	call IsEmptyString
	cmp eax, 1
	je EditPhoneEnd
	
	call ValidatePhone
	cmp eax, 0
	je PhoneValidationFailed
	
	; Check if same as current
	mov ebx, currentUserIndex
	mov eax, 3		; phone field
	call GetUserField	; EDI = pointer to current phone
	mov esi, OFFSET inputPhone
	call CompareStrings
	cmp eax, 0
	je SamePhoneValue
	
	; Check if phone already exists for other users
	call CheckPhoneExists
	cmp eax, 1
	je PhoneAlreadyExists
	
	; Update phone
	mov ebx, currentUserIndex
	mov eax, 3		; phone field
	call GetUserField	; EDI = pointer to phone
	mov esi, OFFSET inputPhone
	mov ecx, PHONE_SIZE
	call CopyStringToBuffer
	
	mov edx, OFFSET updateSuccess
	call WriteString
	jmp EditPhoneEnd

PhoneValidationFailed:
	mov edx, OFFSET phoneError
	call WriteString
	jmp EditPhoneEnd

PhoneAlreadyExists:
	mov edx, OFFSET phoneExistsMsg
	call WriteString
	jmp EditPhoneEnd

SamePhoneValue:
	mov edx, OFFSET sameAsCurrentMsg
	call WriteString

EditPhoneEnd:
	mov edx, OFFSET returnToPortal
	call WriteString
	call ReadChar
	
	pop edi
	pop esi
	pop ecx
	pop ebx
	pop eax
	ret
EditPhone ENDP

; Change password procedure
ChangePassword PROC
	push eax
	push ebx
	push ecx
	push esi
	push edi
	
	call Clrscr
	
	; Get current password for verification
	mov edx, OFFSET currentPasswordPrompt
	call WriteString
	mov edx, OFFSET inputPassword
	mov ecx, PASSWORD_SIZE
	call ReadPasswordMasked
	
	; Verify current password
	mov ebx, currentUserIndex
	mov eax, 1		; password field
	call GetUserField	; EDI = pointer to current password
	mov esi, OFFSET inputPassword
	call CompareStrings
	cmp eax, 0
	jne WrongCurrentPassword
	
	; Get new password
	mov edx, OFFSET newPasswordPrompt
	call WriteString
	mov edx, OFFSET inputPassword
	mov ecx, PASSWORD_SIZE
	call ReadPasswordMasked
	
	; Validate new password
	mov esi, OFFSET inputPassword
	call ValidatePassword
	cmp eax, 0
	je PasswordValidationFailed
	
	; Get password confirmation
	mov edx, OFFSET confirmPasswordPrompt
	call WriteString
	mov edx, OFFSET confirmPassword
	mov ecx, PASSWORD_SIZE
	call ReadPasswordMasked
	
	; Compare passwords
	mov esi, OFFSET inputPassword
	mov edi, OFFSET confirmPassword
	call CompareStrings
	cmp eax, 0
	jne PasswordsDontMatch
	
	; Update password
	mov ebx, currentUserIndex
	mov eax, 1		; password field
	call GetUserField	; EDI = pointer to password
	mov esi, OFFSET inputPassword
	mov ecx, PASSWORD_SIZE
	call CopyStringToBuffer
	
	mov edx, OFFSET updateSuccess
	call WriteString
	jmp ChangePasswordEnd

WrongCurrentPassword:
	mov edx, OFFSET wrongPassword
	call WriteString
	jmp ChangePasswordEnd

PasswordValidationFailed:
	mov edx, OFFSET passwordError
	call WriteString
	jmp ChangePasswordEnd

PasswordsDontMatch:
	mov edx, OFFSET passwordMismatch
	call WriteString

ChangePasswordEnd:
	mov edx, OFFSET returnToPortal
	call WriteString
	call ReadChar
	
	pop edi
	pop esi
	pop ecx
	pop ebx
	pop eax
	ret
ChangePassword ENDP

; Booking portal
BookingPortal PROC
	push eax
	push ebx
	push edx
	push ecx
	push esi
	push edi

	call Clrscr

BookingPortalLoop:

	mov edx, OFFSET bookingHeader
	call WriteString
	call ReadChar
	call WriteChar
	call CrLf

	cmp al, '1'
	je Select2D
	cmp al, '2'
	je SelectIMAX
	cmp al, '3'
	je BackToPortal

	; Invalid choice
	mov edx, OFFSET InvalidChoice
	call WriteString
	jmp BookingPortalLoop

Select2D:
	mov currentMovieType, 0	; 0 = 2D
	call Show2DMovies
	jmp BookingPortalLoop

SelectIMAX:
	mov currentMovieType, 1	; 1 = IMAX
	call ShowIMAXMovies
	jmp BookingPortalLoop

BackToPortal:
	mov edx, OFFSET returnToPortal
	call WriteString
	call WaitMsg
	jmp BookingPortalEnd

BookingPortalEnd:
	pop edi
	pop esi
	pop ecx
	pop edx
	pop ebx
	pop eax
	ret
BookingPortal ENDP

;2D Movie Menu
Show2DMovies PROC
	push eax
	push ebx
	push edx
	push ecx
	push esi
	push edi
	
	call Clrscr

Movie2DLoop:
	mov edx, OFFSET movies2D
	call WriteString
	call ReadInt
	call WriteChar
	call CrLf
	mov userChoice, eax

	cmp eax, 1
	je Valid2DChoice
	cmp eax, 2
	je Valid2DChoice
	cmp eax, 3
	je Valid2DChoice
	cmp eax, 4
	je BackToBooking

	; Invalid choice
	mov edx, OFFSET InvalidChoice
	call WriteString
	jmp Movie2DLoop

Valid2DChoice:
	mov currentMovie, eax
	call ShowShowtimes
	jmp Movie2DLoop

BackToBooking:
	call WaitMsg
	call Clrscr
	jmp Show2DMovieEnd

Show2DMovieEnd:
	pop edi
	pop esi
	pop ecx
	pop edx
	pop ebx
	pop eax
	ret
Show2DMovies ENDP

; IMAX Movie Menu
ShowIMAXMovies PROC
	push eax
	push ebx
	push edx
	push ecx
	push esi
	push edi
	
	call Clrscr

MovieIMAXLoop:
	mov edx, OFFSET moviesIMAX
	call WriteString
	call ReadInt
	call WriteChar
	call CrLf
	mov userChoice, eax
	cmp eax, 1
	je ValidIMAXChoice
	cmp eax, 2
	je ValidIMAXChoice
	cmp eax, 3
	je ValidIMAXChoice
	cmp eax, 4
	je BackToBookingIMAX
	; Invalid choice
	mov edx, OFFSET InvalidChoice
	call WriteString
	jmp MovieIMAXLoop

ValidIMAXChoice:
	mov currentMovie, eax
	call ShowShowtimes
	jmp MovieIMAXLoop


BackToBookingIMAX:
	call WaitMsg
	call Clrscr
	jmp ShowIMAXMovieEnd

ShowIMAXMovieEnd:
	pop edi
	pop esi
	pop ecx
	pop edx
	pop ebx
	pop eax
	ret
ShowIMAXMovies ENDP

;Show showtimes for selected movie
ShowShowtimes PROC
	push eax
	push ebx
	push edx
	push ecx
	push esi
	push edi

	call Clrscr

ShowtimesLoop:
	mov edx, OFFSET showtimesMenu
	call WriteString
	call ReadInt
	call WriteChar
	call CrLf
	mov userChoice, eax

	cmp eax, 1
	je ValidShowtimeChoice
	cmp eax, 2
	je ValidShowtimeChoice
	cmp eax, 3
	je ValidShowtimeChoice
	cmp eax, 4 
	je ValidShowtimeChoice
	cmp eax, 5
	je BackToMovies

	;Invalid choice
	mov edx, OFFSET InvalidChoice
	call WriteString
	jmp ShowtimesLoop

ValidShowtimeChoice:
	mov currentShowtime, eax
	call ShowSeatSelection
	jmp ShowtimesLoop

BackToMovies:
	call WaitMsg
	call Clrscr
	jmp ShowShowtimesEnd

ShowShowtimesEnd:
	pop edi
	pop esi
	pop ecx
	pop edx
	pop ebx
	pop eax
	ret
ShowShowtimes ENDP

; Show seat selection with quantity input
ShowSeatSelection PROC
	push eax
	push ebx
	push edx
	push ecx
	push esi
	push edi
	
	call Clrscr

SeatLoop:
	
	; Display the seat menu header and options first
	cmp currentMovieType, 0
	je Show2DSeats
	; Display IMAX seat menu header and options only
	mov edx, OFFSET seatMenuIMAXHeader
	call WriteString
	jmp ContinueSeatSelection

Show2DSeats:
	; Display 2D seat menu header and options only
	mov edx, OFFSET seatMenu2DHeader
	call WriteString

ContinueSeatSelection:
	; Show available seats for each type
	call DisplayAvailableSeats
	
	; Now display the selection prompt at the bottom
	mov edx, OFFSET seatSelectionPrompt
	call WriteString

	call ReadInt
	mov userChoice, eax

	cmp eax, 1
	je ValidSeatChoice
	cmp eax, 2
	je ValidSeatChoice
	cmp eax, 3
	je ValidSeatChoice
	cmp eax, 4
	je BackToShowtimes
	jmp BackToShowtimes

ValidSeatChoice:
	mov currentSeatType, eax
	
	; Get seat quantity from user
	call GetSeatQuantity
	cmp eax, 0
	je SeatLoop  ; If quantity selection failed, go back to seat selection

	;Check if enough seats are available
	call CheckSeatAvailability
	mov ebx, currentSeatQty

	;testing, display the currect seat availability
	;push eax
	;push ebx
	;push edx
	;mov edx, OFFSET debugCompareMsg  ; BYTE "Available: ",0
	;call WriteString
	;pop edx
	;pop ebx
	;push ebx
	;mov eax, ebx
	;call WriteDec
	;mov edx, OFFSET debugCompareMsg2 ; BYTE " Required: ",0
	;call WriteString
	;pop ebx
	;pop eax
	;push eax
	;call WriteDec
	;call CrLf
	;pop eax

	cmp eax, ebx  ; Compare available seats with requested quantity
	jl NotEnoughSeats  ; Fixed: renamed label to avoid conflict
	
	; After quantity selection and availability check, ask for combo
	call SelectCombo
	
	call ShowBookingSummary
	jmp SeatLoop

BackToShowtimes:
	call WaitMsg
	call Clrscr
	jmp ShowSeatSelectionEnd

NotEnoughSeats:  ; Fixed: renamed from InsufficientSeats
	mov edx, OFFSET insufficientSeats
	call WriteString
	call WaitMsg
	jmp SeatLoop

ShowSeatSelectionEnd:
	pop edi
	pop esi
	pop ecx
	pop edx
	pop ebx
	pop eax
	ret
ShowSeatSelection ENDP

; Get seat quantity from user
; Output: EAX = 1 if successful, 0 if failed
GetSeatQuantity PROC
	push ebx
	push ecx
	push edx

GetQuantityLoop:
	call CrLf
	mov edx, OFFSET seatQtyPrompt
	call WriteString
	call ReadInt
	
	; Validate quantity (1-10)
	cmp eax, 1
	jl InvalidQuantity
	cmp eax, 10
	jg InvalidQuantity
	
	; Store valid quantity
	mov currentSeatQty, eax
	mov eax, 1  ; Success
	jmp GetQuantityEnd

InvalidQuantity:
	mov edx, OFFSET invalidQtyMsg
	call WriteString
	call WaitMsg
	jmp GetQuantityLoop

GetQuantityEnd:
	pop edx
	pop ecx
	pop ebx
	ret
GetSeatQuantity ENDP

; Display available seats for current showtime
DisplayAvailableSeats PROC
    pushad
    
    ; Calculate base index for current showtime
    mov eax, currentShowtime
    dec eax                     ; Convert to 0-based index
    mov ebx, 3                  ; 3 seat types per showtime
    mul ebx                     ; eax = showtime_index * 3
    mov ebx, eax               ; Store base index
    
	call crlf

    ; Display Standard seats
    mov edx, OFFSET seatsAvailable
    call WriteString
    mov eax, OFFSET availableSeats
    mov ecx, ebx
    mov eax, [eax + ecx*4]      ; Get standard seats count
    call WriteDec
    mov al, ' '                 ; Add space character
    call WriteChar
    mov edx, OFFSET standardText
    call WriteString

	call crlf

    
    ; Display Premium seats  
    mov edx, OFFSET seatsAvailable
    call WriteString
    mov eax, OFFSET availableSeats
    mov ecx, ebx
    inc ecx                     ; Move to premium seats
    mov eax, [eax + ecx*4]
    call WriteDec
    mov al, ' '                 ; Add space character
    call WriteChar
    mov edx, OFFSET premiumText
    call WriteString

	call crlf
    
    ; Display Couple seats
    mov edx, OFFSET seatsAvailable
    call WriteString
    mov eax, OFFSET availableSeats
    mov ecx, ebx
    add ecx, 2                  ; Move to couple seats
    mov eax, [eax + ecx*4]
    call WriteDec
    mov al, ' '                 ; Add space character
    call WriteChar
    mov edx, OFFSET coupleText
    call WriteString
	call crlf
	call crlf
    
    popad
    ret
DisplayAvailableSeats ENDP

; Check if selected seat type has availability
CheckSeatAvailability PROC
    push ebx
    push ecx
    push edx
    
    ; Calculate seat index
    mov eax, currentShowtime
    dec eax                     ; Convert to 0-based
    mov ebx, 3
    mul ebx                     ; eax = showtime_index * 3
    add eax, currentSeatType
    dec eax                     ; Add seat type offset (0-based)
    
	; testing
	;push eax
	;push edx
	;mov edx, OFFSET debugIndexMsg  ; 
	;call WriteString
	;mov edx, eax
	;call WriteDec
	;call CrLf
	;pop edx
	;pop eax

     ;Check availability
    mov ebx, OFFSET availableSeats
    mov eax, [ebx + eax*4]      ; store EAX
    pop edx
    pop ecx
    pop ebx
    ret                         ;
CheckSeatAvailability ENDP


ShowBookingSummary PROC
    push eax
    push ebx
    push ecx
    push edx
    push esi
    push edi

    call Clrscr

    ; Display booking summary header
    mov edx, OFFSET bookingSummary
    call WriteString
    call CrLf

    ; Display selected movie name only
    mov edx, OFFSET movieSelected
    call WriteString
    call DisplayMovieName
    call CrLf

    ; Display showtime
    mov edx, OFFSET showtimeSelected
    call WriteString
    mov eax, currentShowtime
    call DisplayShowtimeName
    call CrLf

    ; Display seat type and quantity
    mov edx, OFFSET seatTypeSelected
    call WriteString
    call DisplaySeatTypeName
    call CrLf

    ; Display quantity
    mov edx, OFFSET seatsBooked
    call WriteString
    mov eax, currentSeatQty
    call WriteDec
    mov edx, OFFSET seatsText
    call WriteString
    call CrLf

    ; Display ticket price
    mov edx, OFFSET totalPriceText
    call WriteString
    call CalculateAndDisplayPrice
    call CrLf

    ; Display combo information if selected (combo was already selected earlier)
    cmp currentCombo, 0
    je NoComboSelected

    mov edx, OFFSET comboSelectedText
    call WriteString
    call DisplayComboName
    call CrLf

    ; Display combo quantity
    mov edx, OFFSET comboQtyText
    call WriteString
    mov eax, currentComboQty
    call WriteDec
    call CrLf

    mov edx, OFFSET comboPriceText
    call WriteString
    call DisplayComboPrice
    call CrLf

NoComboSelected:
    ; Display subtotal (before tax)
    mov edx, OFFSET subtotalText
    call WriteString
    call CalculateAndDisplaySubtotal
    call CrLf

    ; Display SST amount
    mov edx, OFFSET sstText
    call WriteString
    call CalculateAndDisplaySST
    call CrLf

    ; Display final total (including SST)
    mov edx, OFFSET finalTotalText
    call WriteString
    call CalculateAndDisplayFinalTotal
    call CrLf
    call CrLf

    ; 1. Confirm booking first
    mov edx, OFFSET confirmBookingPrompt
    call WriteString
    call ValidateYNInput    ; Wait for user input

    cmp al, 'Y'
    je AskPayment
    cmp al, 'y'
    je AskPayment
    ; If not confirmed, return to user portal
    call UserPortal
    jmp BookingSummaryExit

AskPayment:
    ; 2. Proceed to payment
    mov edx, OFFSET paymentPrompt
    call WriteString
    call ValidateYNInput    ; Wait for user input

    cmp al, 'Y'
    je CheckoutPayment
    cmp al, 'y'
    je CheckoutPayment
    jmp BookingSummaryExit

BookingSummaryExit:
    pop edi
    pop esi
    pop edx
    pop ecx
    pop ebx
    pop eax
    ret
ShowBookingSummary ENDP

CalculateAndDisplaySubtotal PROC
	push eax
	push ebx
	push ecx
	push edx
	push esi
	
	; Calculate ticket price in cents
	mov eax, currentSeatType
	dec eax  ; Convert to 0-based index
	
	cmp currentMovieType, 0
	je UseSubtotal2DPrices
	
	; Use IMAX prices
	mov ebx, OFFSET seatPricesIMAX
	jmp GetSubtotalPrice

UseSubtotal2DPrices:
	mov ebx, OFFSET seatPrices2D

GetSubtotalPrice:
	mov ecx, [ebx + eax*4]  ; Get price per seat
	mov eax, currentSeatQty
	mul ecx  ; Total ticket price
	
	; Convert to cents
	mov ebx, 100
	mul ebx  ; EAX = ticket price in cents
	mov esi, eax  ; Store ticket price in ESI
	
	; Add combo price if selected
	cmp currentCombo, 0
	je NoSubtotalComboPrice
	
	mov eax, currentCombo
	dec eax  ; Convert to 0-based index
	mov ebx, OFFSET comboPrices
	mov ecx, [ebx + eax*4]  ; Get combo price per unit in cents
	
	; Multiply by combo quantity
	mov eax, currentComboQty
	mul ecx  ; EAX = total combo price in cents
	
	add esi, eax  ; Add combo price to ticket price

NoSubtotalComboPrice:
	; Display subtotal with decimal
	mov eax, esi  ; Get subtotal price
	mov ebx, 100
	mov edx, 0
	div ebx  ; EAX = whole part, EDX = remainder
	
	push edx  ; Save remainder
	call WriteDec  ; Display whole part
	
	; Display decimal point
	push edx
	mov edx, OFFSET decimalPoint
	call WriteString
	pop edx
	
	; Display decimal part
	pop eax  ; Restore remainder
	cmp eax, 10
	jae DisplaySubtotalTwoDigits
	
	; Single digit, add leading zero
	push eax
	mov al, '0'
	call WriteChar
	pop eax

DisplaySubtotalTwoDigits:
	call WriteDec
	
	pop esi
	pop edx
	pop ecx
	pop ebx
	pop eax
	ret
CalculateAndDisplaySubtotal ENDP

; Calculate and display SST amount (6% of subtotal)
CalculateAndDisplaySST PROC
	push eax
	push ebx
	push ecx
	push edx
	push esi
	
	; Calculate subtotal in cents first
	mov eax, currentSeatType
	dec eax  ; Convert to 0-based index
	
	cmp currentMovieType, 0
	je UseSST2DPrices
	
	; Use IMAX prices
	mov ebx, OFFSET seatPricesIMAX
	jmp GetSSTPrice

UseSST2DPrices:
	mov ebx, OFFSET seatPrices2D

GetSSTPrice:
	mov ecx, [ebx + eax*4]  ; Get price per seat
	mov eax, currentSeatQty
	mul ecx  ; Total ticket price
	
	; Convert to cents
	mov ebx, 100
	mul ebx  ; EAX = ticket price in cents
	mov esi, eax  ; Store ticket price in ESI
	
	; Add combo price if selected
	cmp currentCombo, 0
	je NoSSTComboPrice
	
	mov eax, currentCombo
	dec eax  ; Convert to 0-based index
	mov ebx, OFFSET comboPrices
	mov ecx, [ebx + eax*4]  ; Get combo price per unit in cents
	
	; Multiply by combo quantity
	mov eax, currentComboQty
	mul ecx  ; EAX = total combo price in cents
	
	add esi, eax  ; Add combo price to ticket price

NoSSTComboPrice:
	; Calculate SST (6% of subtotal)
	mov eax, esi  ; Get subtotal in cents
	mov ebx, SST_RATE  ; 6%
	mul ebx  ; EAX = subtotal * 6
	mov ebx, 100
	mov edx, 0
	div ebx  ; EAX = SST amount in cents
	
	; Display SST with decimal
	mov ebx, 100
	mov edx, 0
	div ebx  ; EAX = whole part, EDX = remainder
	
	push edx  ; Save remainder
	call WriteDec  ; Display whole part
	
	; Display decimal point
	push edx
	mov edx, OFFSET decimalPoint
	call WriteString
	pop edx
	
	; Display decimal part
	pop eax  ; Restore remainder
	cmp eax, 10
	jae DisplaySSTTwoDigits
	
	; Single digit, add leading zero
	push eax
	mov al, '0'
	call WriteChar
	pop eax

DisplaySSTTwoDigits:
	call WriteDec
	
	pop esi
	pop edx
	pop ecx
	pop ebx
	pop eax
	ret
CalculateAndDisplaySST ENDP

;Checkout and payment method selection
CheckoutPayment PROC
    push eax
    push ebx
    push ecx
    push edx
    push esi
    push edi
    call Clrscr

CheckoutLoop:
	call Clrscr
    mov edx, OFFSET paymentHeader
    call WriteString
    call ReadInt
    call CrLf
	call DisplayFinalTotalFormatted
	call CrLf

    cmp eax, 1
    je PaywithCard
    cmp eax, 2
    je PaywithEWallet
    cmp eax, 3
    je PaywithOnlineBanking
    cmp eax, 4
    je PaywithRewardPoints
    cmp eax, 5
    je CancelPayment
    
    ; Invalid choice
    mov edx, OFFSET InvalidChoice
    call WriteString
    jmp CheckoutLoop

PaywithCard:
    call ProcessCardPayment
    jmp PaymentEnd

PaywithEWallet:
    call ProcessEWalletPayment
    jmp PaymentEnd

PaywithOnlineBanking:
    call ProcessOnlineBankingPayment
    jmp PaymentEnd

PaywithRewardPoints:
    ; Calculate final total in cents
    call CalculateFinalTotalInCents   ; EAX = total (cents)
    mov finalTotalCents, eax          ; Store total (cents)

    ; Calculate required points = total (cents) ÷ 10
    mov eax, finalTotalCents
    mov ebx, 10
    xor edx, edx
    div ebx                           ; EAX = required points
    mov ecx, eax                      ; ECX = required points

    call ProcessRewardPointsPayment   ; EAX = 1 success, 0 fail
    cmp eax, 1
    jne CheckoutLoop


CancelPayment:
    call UserPortal
    jmp PaymentEnd

PaymentEnd:
    pop edi
    pop esi
    pop edx
    pop ecx
    pop ebx
    pop eax
    ret
CheckoutPayment ENDP

; Update ProcessCardPayment procedure to include reward points
ProcessCardPayment PROC
	push eax
	push ebx
	push ecx
	push edx
	push esi

	call Clrscr
	mov attempts, 0  ; Reset existing attempts counter for card validation
	
CardPaymentLoop:
	; Check if maximum attempts exceeded using existing maxAttempts
	mov eax, attempts
	cmp eax, maxAttempts
	jae MaxCardAttemptsReached

	; Get card number with validation
	call GetCardNumber
	cmp eax, 0
	je CardValidationFailed ; If validation failed, increment attempts

	; Get expiry date with validation  
	call GetCardExpiry
	cmp eax, 0
	je CardValidationFailed ; If validation failed, increment attempts

	; Get CVV with validation
	call GetCardCVV
	cmp eax, 0
	je CardValidationFailed ; If validation failed, increment attempts

	; All validations passed - process payment immediately (no delay)
	call CrLf
	
	; Payment successful
	mov edx, OFFSET paymentSuccess
	call WriteString
	call ProcessSeatBooking ; Update seat availability
	
	; Award reward points
	call AwardRewardPoints
	
	call ReadChar

	; Generate receipt
	call GenerateReceipt

	call UserPortal
	jmp ProcessCardEnd

CardValidationFailed:
	; Increment existing attempt counter
	inc attempts
	jmp CardPaymentLoop

MaxCardAttemptsReached:
	; Display message and return to payment method selection
	mov edx, OFFSET cardAttemptsExceeded
	call WriteString
	call ReadChar
	call CheckoutPayment  ; Return to payment method selection
	jmp ProcessCardEnd

ProcessCardEnd:
	pop esi
	pop edx
	pop ecx
	pop ebx
	pop eax
	ret
ProcessCardPayment ENDP

; Update the GetCardNumber procedure to not loop internally:
; Get and validate card number (must be 16 digits) - Single attempt version
GetCardNumber PROC
	push ebx
	push ecx
	push esi

	; Clear buffer
	mov ecx, 20
	mov esi, OFFSET cardNumber
	call ClearBuffer

	mov edx, OFFSET cardNumberPrompt
	call WriteString
	mov edx, OFFSET cardNumber
	mov ecx, 20
	call ReadString

	; Validate card number (must be exactly 16 digits)
	mov esi, OFFSET cardNumber
	call ValidateCardNumber
	cmp eax, 1
	je CardNumberValid

	mov edx, OFFSET cardNumberError
	call WriteString
	mov eax, 0  ; Return failure
	jmp GetCardNumberEnd

CardNumberValid:
	mov eax, 1 ; Return success

GetCardNumberEnd:
	pop esi
	pop ecx
	pop ebx
	ret
GetCardNumber ENDP

; Update the GetCardExpiry procedure to not loop internally:
; Get and validate card expiry date - Single attempt version
GetCardExpiry PROC
	push ebx
	push ecx
	push esi

	; Clear buffer
	mov ecx, 6
	mov esi, OFFSET cardExpiry
	call ClearBuffer

	mov edx, OFFSET cardExpiryPrompt
	call WriteString
	mov edx, OFFSET cardExpiry
	mov ecx, 6
	call ReadString

	; Validate expiry format (MM/YY)
	mov esi, OFFSET cardExpiry
	call ValidateCardExpiry
	cmp eax, 1
	je ExpiryValid

	mov edx, OFFSET cardExpiryError
	call WriteString
	mov eax, 0  ; Return failure
	jmp GetCardExpiryEnd

ExpiryValid:
	mov eax, 1  ; Return success

GetCardExpiryEnd:
	pop esi
	pop ecx
	pop ebx
	ret
GetCardExpiry ENDP

; Update the GetCardCVV procedure to not loop internally:
; Get and validate CVV - Single attempt version
GetCardCVV PROC
	push ebx
	push ecx
	push esi

	; Clear buffer
	mov ecx, 4
	mov esi, OFFSET cardCVV
	call ClearBuffer

	mov edx, OFFSET cardCVVPrompt
	call WriteString
	mov edx, OFFSET cardCVV
	mov ecx, 4
	call ReadString

	; Validate CVV (must be exactly 3 digits)
	mov esi, OFFSET cardCVV
	call ValidateCardCVV
	cmp eax, 1
	je CVVValid

	mov edx, OFFSET cardCVVError
	call WriteString
	mov eax, 0  ; Return failure
	jmp GetCardCVVEnd

CVVValid:
	mov eax, 1  ; Return success

GetCardCVVEnd:
	pop esi
	pop ecx
	pop ebx
	ret
GetCardCVV ENDP

; Validate card number (16 digits only)
ValidateCardNumber PROC
	push ebx
	push ecx
	push esi

	mov ecx, 0 ; Counter

ValidateCardLoop:
	mov al, [esi]
	cmp al, 0
	je CheckCardLength

	; Check if character is digit
	cmp al, '0'
	jl CardNumberInvalid
	cmp al, '9'
	jg CardNumberInvalid

	inc ecx
	inc esi
	jmp ValidateCardLoop

CheckCardLength:
	; Must be exactly 16 digits
	cmp ecx, 16
	je CardNumberValidResult

CardNumberInvalid:
	mov eax, 0
	jmp ValidateCardEnd

CardNumberValidResult:
	mov eax, 1

ValidateCardEnd:
	pop esi
	pop ecx
	pop ebx
	ret
ValidateCardNumber ENDP

; Validate expiry date format (MM/YY)
ValidateCardExpiry PROC
	push ebx
	push ecx
	push esi

	; Check format: XX/XX (5 characters)
	mov ecx, 0

CountExpiryChars:
	mov al, [esi]
	cmp al, 0
	je CheckExpiryFormat
	inc ecx
	inc esi
	jmp CountExpiryChars

CheckExpiryFormat:
	; Must be exactly 5 characters
	cmp ecx, 5
	jne ExpiryInvalid

	; Reset pointer
	mov esi, OFFSET cardExpiry

	; Check positions: digit, digit, slash, digit, digit
	mov al, [esi]
	cmp al, '0'
	jl ExpiryInvalid
	cmp al, '9'
	jg ExpiryInvalid

	inc esi
	mov al, [esi]
	cmp al, '0'
	jl ExpiryInvalid
	cmp al, '9'
	jg ExpiryInvalid

	inc esi
	mov al, [esi]
	cmp al, '/'
	jne ExpiryInvalid

	inc esi
	mov al, [esi]
	cmp al, '0'
	jl ExpiryInvalid
	cmp al, '9'
	jg ExpiryInvalid

	inc esi
	mov al, [esi]
	cmp al, '0'
	jl ExpiryInvalid
	cmp al, '9'
	jg ExpiryInvalid

	mov eax, 1
	jmp ValidateExpiryEnd

ExpiryInvalid:
	mov eax, 0

ValidateExpiryEnd:
	pop esi
	pop ecx
	pop ebx
	ret
ValidateCardExpiry ENDP

; Validate CVV (3 digits only)
ValidateCardCVV PROC
	push ebx
	push ecx
	push esi

	mov ecx, 0

ValidateCVVLoop:
	mov al, [esi]
	cmp al, 0
	je CheckCVVLength

	; Check if character is digit
	cmp al, '0'
	jl CVVInvalid
	cmp al, '9'
	jg CVVInvalid

	inc ecx
	inc esi
	jmp ValidateCVVLoop

CheckCVVLength:
	; Must be exactly 3 digits
	cmp ecx, 3
	je CVVValidResult

CVVInvalid:
	mov eax, 0
	jmp ValidateCVVEnd

CVVValidResult:
	mov eax, 1

ValidateCVVEnd:
	pop esi
	pop ecx
	pop ebx
	ret
ValidateCardCVV ENDP

; Update ProcessEWalletPayment procedure to include reward points
ProcessEWalletPayment PROC
	push eax
	push edx

	call Clrscr

EWalletLoop:
	mov edx, OFFSET EwalletPrompt
	call WriteString
	call ReadInt
	call CrLf

	cmp eax, 1
	je GrabPaySelected
	cmp eax, 2
	je TouchNGoSelected
	cmp eax, 3
	je BoostSelected

	mov edx, OFFSET InvalidChoice
	call WriteString
	jmp EWalletLoop

GrabPaySelected:
	mov edx, OFFSET ewalletOptions
	call WriteString
	mov edx, OFFSET grabpay
	call WriteString
	call CrLf
	jmp ShowQRCode

TouchNGoSelected:
	mov edx, OFFSET ewalletOptions
	call WriteString
	mov edx, OFFSET touchngo
	call WriteString
	call CrLf
	jmp ShowQRCode

BoostSelected:
	mov edx, OFFSET ewalletOptions
	call WriteString
	mov edx, OFFSET boost
	call WriteString
	call CrLf
	jmp ShowQRCode

ShowQRCode:
	call CrLf
	mov edx, OFFSET QRPrompt
	call WriteString
	call CrLf
	mov edx, OFFSET QRImage
	call WriteString
	call CrLf

	; Keep 10 second delay only for QR code scanning simulation
	mov edx, OFFSET processingCodeMsg
	call WriteString
	mov eax, 10000
	call Delay

	mov edx, OFFSET QRSuccess
	call WriteString
	call ProcessSeatBooking ; Update seat availability
	
	; Award reward points
	call AwardRewardPoints
	
	call ReadChar

	; Generate receipt
	call GenerateReceipt

	call UserPortal

	pop edx
	pop eax
	ret
ProcessEWalletPayment ENDP

; Update ProcessOnlineBankingPayment procedure to include reward points
ProcessOnlineBankingPayment PROC
	push eax
	push edx

	call Clrscr

BankingLoop:
	mov edx, OFFSET bankingPrompt
	call WriteString
	call ReadInt
	call CrLf

	cmp eax, 1
	je MaybankSelected
	cmp eax, 2
	je CIMBSelected
	cmp eax, 3
	je PublicBankSelected

	mov edx, OFFSET InvalidChoice
	call WriteString
	jmp BankingLoop

MaybankSelected:
	mov edx, OFFSET selectedBankMsg
	call WriteString
	mov edx, OFFSET maybank
	call WriteString
	call CrLf
	jmp GetBankingCredentials

CIMBSelected:
	mov edx, OFFSET selectedBankMsg
	call WriteString
	mov edx, OFFSET cimb
	call WriteString
	call CrLf
	jmp GetBankingCredentials

PublicBankSelected:
	mov edx, OFFSET selectedBankMsg
	call WriteString
	mov edx, OFFSET publicbank
	call WriteString
	call CrLf
	jmp GetBankingCredentials

GetBankingCredentials:
	call CrLf

	; Clear buffers
	mov ecx, 30
	mov esi, OFFSET bankingUsername
	call ClearBuffer

	mov ecx, 20
	mov esi, OFFSET bankingPassword
	call ClearBuffer

	; Get username
	mov edx, OFFSET bankingUsernamePrompt
	call WriteString
	mov edx, OFFSET bankingUsername
	mov ecx, 30
	call ReadString

	; Get password (masked)
	mov edx, OFFSET bankingPasswordPrompt
	call WriteString
	mov edx, OFFSET bankingPassword
	mov ecx, 20
	call ReadPasswordMasked

	; Process payment immediately (no delay)
	call CrLf

	mov edx, OFFSET paymentSuccess
	call WriteString
	call ProcessSeatBooking ; Update seat availability
	
	; Award reward points
	call AwardRewardPoints
	
	call ReadChar

	; Generate receipt
	call GenerateReceipt

	call UserPortal

	pop edx
	pop eax
	ret
ProcessOnlineBankingPayment ENDP

; ProcessRewardPointsPayment
ProcessRewardPointsPayment PROC
    ; Input: ECX = required points for this purchase
    push ebx
    push ecx
    push edx
    push esi
    push edi

    ; Get current user's reward points
    mov eax, 4                        ; field index for reward points
    mov ebx, currentUserIndex
    call GetUserField                 ; EDI = pointer to reward points
    movzx eax, WORD PTR [edi]         ; EAX = current reward points (WORD)
    mov ebx, eax                      ; EBX = available points

    ; Show available points
    mov edx, OFFSET availableMsg
    call WriteString
    mov eax, ebx
    call WriteDec
    call CrLf

    ; Show required points
    mov edx, OFFSET requiredMsg
    call WriteString
    mov eax, ecx                      ; ECX = required points
    call WriteDec
    call CrLf

    ; Compare available vs required
    cmp ebx, ecx
    jb NotEnoughPoints                ; if available < required

    ; Confirm payment with reward points
    mov edx, OFFSET confirmBookingPrompt
    call WriteString
    call ValidateYNInput
    
    cmp al, 'Y'
    je ConfirmRewardPayment
    cmp al, 'y'
    je ConfirmRewardPayment
    
    ; User cancelled
    mov eax, 0
    jmp EndProcessRewardPointsPayment

ConfirmRewardPayment:
    ; Deduct required points
    sub ebx, ecx
    mov WORD PTR [edi], bx           ; Store updated points (WORD)

    ; Success
    mov edx, OFFSET successMsg
    call WriteString
    call CrLf
	call ProcessSeatBooking
	call GenerateReceipt
    mov eax, 1                        ; success flag
    jmp EndProcessRewardPointsPayment

NotEnoughPoints:
    mov edx, OFFSET notEnoughPointsMsg
    call WriteString
    call CrLf

    ; Show "press any key to continue"
    mov edx, OFFSET pressAnyKeyMsg
    call WriteString
    call ReadChar
    call CrLf

    mov eax, 0                        ; fail flag

EndProcessRewardPointsPayment:
    pop edi
    pop esi
    pop edx
    pop ecx
    pop ebx
    ret
ProcessRewardPointsPayment ENDP

; Generate receipt after successful payment
GenerateReceipt PROC
	push eax
	push ebx
	push ecx
	push edx
	push esi
	push edi

	call Clrscr

	; Display receipt header
	mov edx, OFFSET receiptHeader
	call WriteString
	call CrLf

	; Get current system time
	INVOKE GetLocalTime, ADDR sysTime

	; Display actual date and time
	call DisplayReceiptDateTime
	call CrLf

	; Display customer name
	mov edx, OFFSET receiptCustomerLabel
	call WriteString
	mov edx, OFFSET currentUser
	call WriteString
	call CrLf
	call CrLf

	; Display transaction details with proper spacing
	mov al, '-'
	mov ecx, 47
PrintDashes1:
	call WriteChar
	loop PrintDashes1
	call CrLf

	; Display movie information with padding
	mov edx, OFFSET movieSelected
	call WriteString
	call DisplayMovieName
	call CrLf

	; Display showtime with padding
	mov edx, OFFSET showtimeSelected
	call WriteString
	mov eax, currentShowtime
	call DisplayShowtimeName
	call CrLf

	; Display seat information with padding
	mov edx, OFFSET seatTypeSelected
	call WriteString
	call DisplaySeatTypeName
	call CrLf

	; Display quantity with proper formatting
	mov edx, OFFSET seatsBooked
	call WriteString
	mov eax, currentSeatQty
	call WriteDec
	mov edx, OFFSET seatsText
	call WriteString
	call CrLf

	call CrLf

	; Ticket pricing section
	call DisplayTicketPricing
	call CrLf

	; Display combo information if selected
	cmp currentCombo, 0
	je NoReceiptCombo

	call DisplayComboPricing

NoReceiptCombo:
	; Display separator line
	mov al, '-'
	mov ecx, 47
PrintDashes2:
	call WriteChar
	loop PrintDashes2
	call CrLf

	; Display final total with emphasis
	call DisplayFinalTotalFormatted
	call CrLf

	; Display separator line
	mov al, '='
	mov ecx, 47
PrintEquals:
	call WriteChar
	loop PrintEquals
	call CrLf
	call CrLf

	; Display receipt footer
	mov edx, OFFSET receiptFooter
	call WriteString

	; Wait for user to continue
	mov edx, OFFSET returnToPortal
	call WriteString
	call ReadChar

	pop edi
	pop esi
	pop edx
	pop ecx
	pop ebx
	pop eax
	ret
GenerateReceipt ENDP

; Display ticket pricing with proper alignment
DisplayTicketPricing PROC
	push eax
	push ebx
	push ecx
	push edx

	; Display ticket line item
	mov eax, currentSeatQty
	call WriteDec
	mov al, 'x'
	call WriteChar
	mov al, ' '
	call WriteChar
	
	call DisplaySeatTypeName
	mov al, ' '
	call WriteChar
	mov al, '('
	call WriteChar
	
	; Display movie type
	cmp currentMovieType, 0
	je Display2DType
	mov edx, OFFSET movieTypeIMAX
	jmp DisplayType
Display2DType:
	mov edx, OFFSET movieType2D
DisplayType:
	call WriteString
	mov al, ')'
	call WriteChar
	
	; Add spacing and display price
	call DisplayRightAlignedPrice
	call CrLf

	pop edx
	pop ecx
	pop ebx
	pop eax
	ret
DisplayTicketPricing ENDP


; Display combo pricing with proper alignment
DisplayComboPricing PROC
	push eax
	push edx

	; Display combo line item
	mov eax, currentComboQty
	call WriteDec
	mov al, 'x'
	call WriteChar
	mov al, ' '
	call WriteChar
	
	call DisplayComboName
	call CrLf
	
	; Display combo price with right alignment
	mov al, ' '
	mov ecx, 25
PrintSpaces:
	call WriteChar
	loop PrintSpaces
	
	mov edx, OFFSET comboPriceText
	call WriteString
	call DisplayComboPrice
	call CrLf
	call CrLf

	pop edx
	pop eax
	ret
DisplayComboPricing ENDP

; Display right-aligned price for tickets
DisplayRightAlignedPrice PROC
	push eax
	push edx

	; Add spacing for right alignment
	mov al, ' '
	mov ecx, 15
AlignSpaces:
	call WriteChar
	loop AlignSpaces

	mov edx, OFFSET totalPriceText
	call WriteString
	call CalculateAndDisplayPrice

	pop edx
	pop eax
	ret
DisplayRightAlignedPrice ENDP

; Display formatted final total with emphasis
DisplayFinalTotalFormatted PROC
	push eax
	push edx

	; Display subtotal first
	mov al, ' '
	mov ecx, 10
SubtotalSpaces:
	call WriteChar
	loop SubtotalSpaces
	mov edx, OFFSET subtotalText
	call WriteString
	call CalculateAndDisplaySubtotal
	call CrLf

	; Display SST
	mov al, ' '
	mov ecx, 10
SSTSpaces:
	call WriteChar
	loop SSTSpaces
	mov edx, OFFSET sstText
	call WriteString
	call CalculateAndDisplaySST
	call CrLf

	; Display separator line
	mov al, '-'
	mov ecx, 47
PrintDashes:
	call WriteChar
	loop PrintDashes
	call CrLf

	; Display "TOTAL:" with emphasis
	mov al, ' '
	mov ecx, 10
TotalSpaces:
	call WriteChar
	loop TotalSpaces

	mov edx, OFFSET finalTotalText
	call WriteString
	call CalculateAndDisplayFinalTotal

	pop edx
	pop eax
	ret
DisplayFinalTotalFormatted ENDP
; Display formatted date and time on receipt using actual system time
DisplayReceiptDateTime PROC
	push eax
	push ebx
	push edx

	; Display date label
	mov edx, OFFSET receiptDateLabel
	call WriteString
	
	; Display month
	movzx eax, sysTime.wMonth
	call WriteDec
	mov edx, OFFSET slashChar
	call WriteString
	
	; Display day
	movzx eax, sysTime.wDay
	call WriteDec
	mov edx, OFFSET slashChar
	call WriteString
	
	; Display year
	movzx eax, sysTime.wYear
	call WriteDec

	; Add spaces between date and time
	mov al, ' '
	call WriteChar
	call WriteChar
	call WriteChar

	; Display time label
	mov edx, OFFSET receiptTimeLabel
	call WriteString
	
	; Display hours
	movzx eax, sysTime.wHour
	call WriteDec
	mov edx, OFFSET colonChar
	call WriteString
	
	; Display minutes with leading zero if needed
	movzx eax, sysTime.wMinute
	cmp eax, 10
	jae DisplayMinutes
	mov al, '0'
	call WriteChar
	movzx eax, sysTime.wMinute

DisplayMinutes:
	call WriteDec
	mov edx, OFFSET colonChar
	call WriteString
	
	; Display seconds with leading zero if needed
	movzx eax, sysTime.wSecond
	cmp eax, 10
	jae DisplaySeconds
	mov al, '0'
	call WriteChar
	movzx eax, sysTime.wSecond

DisplaySeconds:
	call WriteDec

	pop edx
	pop ebx
	pop eax
	ret
DisplayReceiptDateTime ENDP

DisplayMovieName PROC
	push eax
	push edx
	
	; Display movie type first
	cmp currentMovieType, 0
	je Display2DMovie
	
	; IMAX movie
	mov edx, OFFSET movie1_IMAX
	mov eax, currentMovie
	cmp eax, 1
	je DisplaySelectedMovie
	
	mov edx, OFFSET movie2_IMAX
	cmp eax, 2
	je DisplaySelectedMovie
	
	mov edx, OFFSET movie3_IMAX
	cmp eax, 3
	je DisplaySelectedMovie
	jmp DisplayMovieEnd

Display2DMovie:
	; 2D movie
	mov edx, OFFSET movie1_2D
	mov eax, currentMovie
	cmp eax, 1
	je DisplaySelectedMovie
	
	mov edx, OFFSET movie2_2D
	cmp eax, 2
	je DisplaySelectedMovie
	
	mov edx, OFFSET movie3_2D
	cmp eax, 3
	je DisplaySelectedMovie
	jmp DisplayMovieEnd

DisplaySelectedMovie:
	call WriteString
	mov al, ' '
	call WriteChar
	mov al, '('
	call WriteChar
	cmp currentMovieType, 0
	je Display2DLabel
	mov edx, OFFSET movieTypeIMAX
	jmp DisplayLabel
Display2DLabel:
	mov edx, OFFSET movieType2D
DisplayLabel:
	call WriteString
	mov al, ')'
	call WriteChar

DisplayMovieEnd:
	pop edx
	pop eax
	ret
DisplayMovieName ENDP

; Display showtime name based on currentShowtime
DisplayShowtimeName PROC
	push edx
	
	cmp eax, 1
	je ShowTime1
	cmp eax, 2
	je ShowTime2
	cmp eax, 3
	je ShowTime3
	cmp eax, 4
	je ShowTime4
	jmp ShowTimeEnd

ShowTime1:
	mov edx, OFFSET showtime1Text
	jmp DisplayTime
ShowTime2:
	mov edx, OFFSET showtime2Text
	jmp DisplayTime
ShowTime3:
	mov edx, OFFSET showtime3Text
	jmp DisplayTime
ShowTime4:
	mov edx, OFFSET showtime4Text
DisplayTime:
	call WriteString

ShowTimeEnd:
	pop edx
	ret
DisplayShowtimeName ENDP

; Display seat type name
DisplaySeatTypeName PROC
	push eax
	push edx
	
	mov eax, currentSeatType
	cmp eax, 1
	je SeatStandard
	cmp eax, 2
	je SeatPremium
	cmp eax, 3
	je SeatCouple
	jmp SeatTypeEnd

SeatStandard:
	mov edx, OFFSET standardText
	jmp DisplaySeatType
SeatPremium:
	mov edx, OFFSET premiumText
	jmp DisplaySeatType
SeatCouple:
	mov edx, OFFSET coupleText
DisplaySeatType:
	call WriteString

SeatTypeEnd:
	pop edx
	pop eax
	ret
DisplaySeatTypeName ENDP

; Calculate and display total price
CalculateAndDisplayPrice PROC
	push eax
	push ebx
	push ecx
	
	; Get price per seat
	mov eax, currentSeatType
	dec eax  ; Convert to 0-based index
	
	cmp currentMovieType, 0
	je Use2DPrices
	
	; Use IMAX prices
	mov ebx, OFFSET seatPricesIMAX
	jmp GetPrice

Use2DPrices:
	mov ebx, OFFSET seatPrices2D

GetPrice:
	mov ecx, [ebx + eax*4]  ; Get price per seat
	mov eax, currentSeatQty
	mul ecx  ; Total price = quantity * price per seat
	call WriteDec
	
	pop ecx
	pop ebx
	pop eax
	ret
CalculateAndDisplayPrice ENDP

; Process the actual seat booking (update available seats)
ProcessSeatBooking PROC
	push eax
	push ebx
	push ecx
	push edx
	
	; Calculate seat index in availableSeats array
	mov eax, currentShowtime
	dec eax  ; Convert to 0-based
	mov ebx, 3
	mul ebx  ; eax = showtime_index * 3
	add eax, currentSeatType
	dec eax  ; Add seat type offset (0-based)
	
	; Update available seats
	mov ebx, OFFSET availableSeats
	mov ecx, [ebx + eax*4]  ; Get current available seats
	sub ecx, currentSeatQty  ; Subtract booked seats
	mov [ebx + eax*4], ecx  ; Store updated count
	
	pop edx
	pop ecx
	pop ebx
	pop eax
	ret
ProcessSeatBooking ENDP

GetCredentials PROC
	;Clear input buffers
	mov ecx, 20
	mov esi, OFFSET inputUsername
	call ClearBuffer

	mov ecx, 20
	mov esi, OFFSET inputPassword
	call ClearBuffer

	;-- Username --
	call Crlf
	mov edx, OFFSET usernamePrompt
	call WriteString
	mov edx, OFFSET inputUsername
	mov ecx, SIZEOF inputUsername
	call ReadString

	;-- Password --
	mov edx, OFFSET passwordPrompt
	call WriteString
	mov edx, OFFSET inputPassword
	mov ecx, SIZEOF inputPassword
	call ReadPasswordMasked
	ret
GetCredentials ENDP

; Read password with masking (shows asterisks)
; Input: EDX = buffer address, ECX = buffer size
; Output: Password stored in buffer
ReadPasswordMasked PROC
	push eax
	push ebx
	push ecx
	push edx
	push esi
	
	mov esi, edx		; ESI = buffer address
	mov ebx, 0			; EBX = character count
	dec ecx				; Leave space for null terminator

ReadPasswordLoop:
	call ReadChar		; Read character without echo
	
	; Check for Enter key
	cmp al, ENTER_KEY
	je PasswordComplete
	
	; Check for Backspace
	cmp al, BACKSPACE_KEY
	je HandleBackspace
	
	; Check if buffer is full
	cmp ebx, ecx
	jae ReadPasswordLoop	; Skip if buffer full
	
	; Store character in buffer
	mov [esi + ebx], al
	inc ebx
	
	; Display asterisk
	mov al, '*'
	call WriteChar
	jmp ReadPasswordLoop

HandleBackspace:
	; Check if there are characters to delete
	cmp ebx, 0
	je ReadPasswordLoop
	
	; Remove character from buffer
	dec ebx
	mov al, 0
	mov [esi + ebx], al
	
	; Move cursor back and overwrite asterisk
	mov al, BACKSPACE_KEY
	call WriteChar
	mov al, ' '
	call WriteChar
	mov al, BACKSPACE_KEY
	call WriteChar
	jmp ReadPasswordLoop

PasswordComplete:
	; Null-terminate the string
	mov al, 0
	mov [esi + ebx], al
	call CrLf			; Move to next line
	
	pop esi
	pop edx
	pop ecx
	pop ebx
	pop eax
	ret
ReadPasswordMasked ENDP

; Combined Credential Validation (replaces ValidateAdminCredentials and ValidateUserCredentials)
; Input: EBX = validation type (0 = admin, 1 = user)
; Output: EAX = 1 if valid, 0 if invalid
ValidateCredentials PROC
	push ebx
	push ecx
	push edi
	
	cmp ebx, 0
	je ValidateAdmin
	jmp ValidateUser

ValidateAdmin:
	; Compare username
	mov esi, OFFSET inputUsername
	mov edi, OFFSET adminUsername
	call CompareStrings
	cmp eax, 0
	jne CredentialsInvalid

	; Compare password
	mov esi, OFFSET inputPassword
	mov edi, OFFSET adminPassword
	call CompareStrings
	cmp eax, 0
	jne CredentialsInvalid

	; Both match
	mov eax, 1
	jmp ValidateEnd

ValidateUser:
	mov ebx, 0		; Index for users

ValidateUserLoop:
	cmp ebx, userCount
	jae CredentialsInvalid		; Changed: jge to jae

	; Get username field for current user
	mov eax, 0		; 0 = username field
	call GetUserField	; EDI = pointer to username
	
	; Compare username
	mov esi, OFFSET inputUsername
	call CompareStrings
	cmp eax, 0
	jne NextUser		; Username doesn't match
	
	; Get password field for current user
	mov eax, 1		; 1 = password field
	call GetUserField	; EDI = pointer to password
	
	; Compare password
	mov esi, OFFSET inputPassword
	call CompareStrings
	cmp eax, 0
	je CredentialsValid	; Both match!

NextUser:
	inc ebx
	jmp ValidateUserLoop

CredentialsValid:
	mov eax, 1
	jmp ValidateEnd

CredentialsInvalid:
	mov eax, 0

ValidateEnd:
	pop edi
	pop ecx
	pop ebx
	ret
ValidateCredentials ENDP

CompareStrings PROC
	; Compares two null-terminated strings
	; ESI = first string, EDI = second string
	; Returns 0 if equal, non-zero if not
	push ebx
	push ecx
	push esi
	push edi
	
	; Safety check for null pointers
	cmp esi, 0
	je NotEqual
	cmp edi, 0
	je NotEqual

CompareLoop:
	mov al, [esi]
	mov bl, [edi]
	cmp al, bl
	jne NotEqual

	cmp al, 0
	je Equal
	inc esi
	inc edi
	jmp CompareLoop

NotEqual:
	mov eax, 1
	jmp CompareEnd

Equal:
	mov eax, 0

CompareEnd:
	pop edi
	pop esi
	pop ecx
	pop ebx
	ret
CompareStrings ENDP

IsEmptyString PROC
	push ebx

	mov al, BYTE PTR [esi]
	cmp al, 0
	je IsEmpty
	cmp al, 20h
	je IsEmpty
	cmp al, 09h
	je IsEmpty

	; Not empty
	mov eax, 0
	jmp IsEmptyEnd

IsEmpty:
	mov eax, 1

IsEmptyEnd:
	pop ebx
	ret
IsEmptyString ENDP

ClearBuffer PROC
	;Input: ESI = buffer, ECX = size
	push eax
	push edi
	push ecx

	mov edi, esi
	mov al, 0
	rep stosb

	pop ecx
	pop edi
	pop eax
	ret
ClearBuffer ENDP

; Select combo procedure
SelectCombo PROC
	push eax
	push edx
	
	; Initialize combo values to safe defaults
	mov currentCombo, 0
	mov currentComboQty, 0
	
	; Ask if user wants combo
	mov edx, OFFSET comboPrompt
	call WriteString
	call ValidateYNInput
	
	cmp al, 'Y'
	je ShowComboMenu
	cmp al, 'y'
	je ShowComboMenu
	
	; User doesn't want combo - values already set to 0
	jmp SelectComboEnd

ShowComboMenu:
	call CrLf
	mov edx, OFFSET comboMenuHeader
	call WriteString
	mov edx, OFFSET comboSelectionPrompt
	call WriteString
	
	call ReadInt
	
	; Validate combo choice
	cmp eax, 1
	jl InvalidComboChoice
	cmp eax, 4
	jg InvalidComboChoice
	
	; Valid choice
	cmp eax, 4
	je NoComboChoice
	mov currentCombo, eax
	
	; Ask for combo quantity
	call GetComboQuantity
	jmp SelectComboEnd

NoComboChoice:
	mov currentCombo, 0
	mov currentComboQty, 0
	jmp SelectComboEnd

InvalidComboChoice:
	mov edx, OFFSET InvalidChoice
	call WriteString
	jmp ShowComboMenu

SelectComboEnd:
	pop edx
	pop eax
	ret
SelectCombo ENDP

; Get combo quantity from user
; Output: Sets currentComboQty
GetComboQuantity PROC
	push eax
	push edx

GetComboQtyLoop:
	call CrLf
	mov edx, OFFSET comboQtyPrompt
	call WriteString
	call ReadInt
	
	; Validate quantity (minimum 1, no maximum limit)
	cmp eax, 1
	jl InvalidComboQty
	
	; Store valid quantity (no upper limit check)
	mov currentComboQty, eax
	jmp GetComboQtyEnd

InvalidComboQty:
	mov edx, OFFSET invalidQtyMsg
	call WriteString
	call WaitMsg
	jmp GetComboQtyLoop

GetComboQtyEnd:
	pop edx
	pop eax
	ret
GetComboQuantity ENDP

; Display combo name based on currentCombo
DisplayComboName PROC
	push eax
	push edx
	
	mov eax, currentCombo
	cmp eax, 1
	je DisplayComboA
	cmp eax, 2
	je DisplayComboB
	cmp eax, 3
	je DisplayComboC
	jmp DisplayComboEnd

DisplayComboA:
	mov edx, OFFSET comboAText
	jmp DisplayCombo
DisplayComboB:
	mov edx, OFFSET comboBText
	jmp DisplayCombo
DisplayComboC:
	mov edx, OFFSET comboCText
DisplayCombo:
	call WriteString

DisplayComboEnd:
	pop edx
	pop eax
	ret
DisplayComboName ENDP

; Remove these duplicate procedures (lines near the end of the file):

; Display combo price with decimal places
DisplayComboPrice PROC
	push eax
	push ebx
	push ecx
	push edx
	
	mov eax, currentCombo
	cmp eax, 0
	je DisplayComboPriceEnd
	
	dec eax  ; Convert to 0-based index
	mov ebx, OFFSET comboPrices
	mov ecx, [ebx + eax*4]  ; Get price per combo in cents
	
	; Multiply by quantity
	mov eax, currentComboQty
	cmp eax, 0
	je DisplayComboPriceEnd  ; Safety check
	
	; Use 16-bit multiplication to prevent overflow
	cmp eax, 65535
	jae DisplayComboPriceEnd  ; Prevent overflow
	
	mul ecx  ; EAX = total combo price in cents
	
	; Display whole part (divide by 100)
	mov ebx, 100
	mov edx, 0
	div ebx  ; EAX = whole part, EDX = remainder (cents)
	
	push edx  ; Save remainder
	call WriteDec  ; Display whole part
	
	; Display decimal point
	push edx
	mov edx, OFFSET decimalPoint
	call WriteString
	pop edx
	
	; Display decimal part
	pop eax  ; Restore remainder
	cmp eax, 10
	jae DisplayTwoDigits
	
	; Single digit, add leading zero
	push eax
	mov al, '0'
	call WriteChar
	pop eax

DisplayTwoDigits:
	call WriteDec

DisplayComboPriceEnd:
	pop edx
	pop ecx
	pop ebx
	pop eax
	ret
DisplayComboPrice ENDP

; Calculate and display final total (tickets + combo)
CalculateAndDisplayFinalTotal PROC
	push eax
	push ebx
	push ecx
	push edx
	push esi
	
	; Calculate ticket price in cents
	mov eax, currentSeatType
	dec eax  ; Convert to 0-based index
	
	cmp currentMovieType, 0
	je UseFinal2DPrices
	
	; Use IMAX prices
	mov ebx, OFFSET seatPricesIMAX
	jmp GetFinalPrice

UseFinal2DPrices:
	mov ebx, OFFSET seatPrices2D

GetFinalPrice:
	mov ecx, [ebx + eax*4]  ; Get price per seat
	mov eax, currentSeatQty
	mul ecx  ; Total ticket price
	
	; Convert to cents
	mov ebx, 100
	mul ebx  ; EAX = ticket price in cents
	mov esi, eax  ; Store ticket price in ESI
	
	; Add combo price if selected
	cmp currentCombo, 0
	je NoComboPrice
	
	mov eax, currentCombo
	dec eax  ; Convert to 0-based index
	mov ebx, OFFSET comboPrices
	mov ecx, [ebx + eax*4]  ; Get combo price per unit in cents
	
	; Multiply by combo quantity
	mov eax, currentComboQty
	mul ecx  ; EAX = total combo price in cents
	
	add esi, eax  ; Add combo price to ticket price

NoComboPrice:
	; Calculate SST (6% of subtotal) and add to total
	mov eax, esi  ; Get subtotal in cents
	mov ebx, SST_RATE  ; 6%
	mul ebx  ; EAX = subtotal * 6
	mov ebx, 100
	mov edx, 0
	div ebx  ; EAX = SST amount in cents
	
	add esi, eax  ; Add SST to subtotal for final total

	; Display final total with decimal
	mov eax, esi  ; Get total price (including SST)
	mov ebx, 100
	mov edx, 0
	div ebx  ; EAX = whole part, EDX = remainder
	
	push edx  ; Save remainder
	call WriteDec  ; Display whole part
	
	; Display decimal point
	push edx
	mov edx, OFFSET decimalPoint
	call WriteString
	pop edx
	
	; Display decimal part
	pop eax  ; Restore remainder
	cmp eax, 10
	jae DisplayFinalTwoDigits
	
	; Single digit, add leading zero
	push eax
	mov al, '0'
	call WriteChar
	pop eax

DisplayFinalTwoDigits:
	call WriteDec
	
	pop esi
	pop edx
	pop ecx
	pop ebx
	pop eax
	ret
CalculateAndDisplayFinalTotal ENDP

ValidateYNInput PROC
    push edx

ValidateYNLoop:
    call ReadChar
    call WriteChar
    call CrLf

    ; Check for valid Y/N responses
    cmp al, 'Y'
    je ValidYNInput
    cmp al, 'y'
    je ValidYNInput
    cmp al, 'N'
    je ValidYNInput
    cmp al, 'n'
    je ValidYNInput

    ; Invalid input - show error and retry
    mov edx, OFFSET invalidYNMsg
    call WriteString
    jmp ValidateYNLoop

ValidYNInput:
    pop edx
    ret
ValidateYNInput ENDP

End main
